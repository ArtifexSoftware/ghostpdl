% Copyright (C) 2001-2023 Artifex Software, Inc.
% All Rights Reserved.
%
% This software is provided AS-IS with no warranty, either express or
% implied.
%
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
%
% Refer to licensing information at http://www.artifex.com or contact
% Artifex Software, Inc.,  39 Mesa Street, Suite 108A, San Francisco,
% CA 94129, USA, for further information.
%

% Font initialization and management code.

% Define the default font.
/defaultfontname /Courier def

% Define the name of the font map file.
% Note that the "%%Replace " comment below provides the font map file name
% for compiling initialization files into executable. Most likely it should be
% consistent with the one specified here.
/FONTMAP where
{/FONTMAP get /defaultfontmap exch def}
{/defaultfontmap (Fontmap) def}
ifelse

% we have to set .languagelevel to 2 so the parser will accept the names
% '<<' and '>>', then we use a local definition here.
.languagelevel 2 .setlanguagelevel
/defaultfontmap_content 50 dict
4 dict begin
(<<) cvn /mark load def
(>>) cvn /.dicttomark load def
/; { 2 index 3 1 roll .growput }.internalbind def
%% Replace 0 (Fontmap)
end def
.setlanguagelevel

% ------ End of editable parameters ------ %

% Define the UniqueIDs and organization XUID assigned to Artifex.
% UniqueIDs 5,066,501 - 5,066,580 are assigned as follows:
%   01 and 02 for shareware Cyrillic
%   33 through 67 for Type 1 versions of the Hershey fonts
% UniqueIDs 5,115,501 - 5,115,600 are currently unassigned.
/AladdinEnterprisesXUID 107 def

% If SUBSTFONT is defined, make it the default font.
/SUBSTFONT where { pop /defaultfontname /SUBSTFONT load def } if

% Define a reliable way of accessing FontDirectory in systemdict.
/.FontDirectory
{ /FontDirectory .systemvar
} .forcebind odef

% Define a temporary string for local use, since using =string
% interferes with some PostScript programs.
/.fonttempstring 8192 string def

% Split up a search path into individual directories or files.
/.pathlist              % <path> .pathlist <dir1|file1> ...
 {  { dup length 0 eq { pop exit } if
      .filenamelistseparator search not { exit } if
      exch pop exch
    }
   loop
 }.internalbind def

% <dir.../base.extn> .basename <dir>
/.splitdirname {
    (/) rsearch { //true } { (\\) rsearch } ifelse
  {exch concatstrings exch pop //true}{//false} ifelse
}.internalbind def

% <dict> .addfontmappermitpaths
% As fontmap can contain a *lot* of individual entries
% we split off the filenames, and add directories to the
% allowed paths.
% We accumulate the paths in a dictionary, then iterate
% the dictionary adding the paths to the PermitReading
% list. This leverages the efficiency of dictionaries
% handling duplicate keys.
/.addfontmappermitpaths
{
  dup length dict begin
  {
    exch pop dup type /stringtype eq
    {//.splitdirname exec {dup def} {pop} ifelse}
    {pop}
    ifelse
  } forall
  currentdict end
  {exch pop /PermitFileReading exch .addcontrolpath}forall
}.internalbind def

defaultfontmap_content length 0 gt
{defaultfontmap_content .addfontmappermitpaths} if

% Load a font name -> font file name map.
userdict /Fontmap .FontDirectory maxlength dict put
userdict /.nativeFontmap .FontDirectory maxlength dict put
/.loadFontmap {         % <file> .loadFontmap -
                % We would like to simply execute .definefontmap as we read,
                % but we have to maintain backward compatibility with an older
                % specification that makes later entries override earlier
                % ones within the same file.
   50 dict exch .readFontmap
   dup //.addfontmappermitpaths exec
   { .definefontmap } forall
}.internalbind def
/.readFontmap {         % <dict> <file> .readFontmap <dict>
    { dup token not { closefile exit } if
                % stack: dict file fontname
      % This is a hack to get around the absurd habit of MS-DOS editors
      % of adding an EOF character at the end of the file.
      dup (\032) eq { pop closefile exit } if
      1 index token not
       { (Fontmap entry for ) print dup =only
         ( has no associated file or alias name!  Giving up.) = flush
         {.readFontmap} 0 get 1 .quit
       } if
      dup type dup /stringtype eq exch /nametype eq or not
       { (Fontmap entry for ) print 1 index =only
         ( has an invalid file or alias name!  Giving up.) = flush
         {.readFontmap} 0 get 1 .quit
       } if
                % stack: dict file fontname filename|aliasname
      dup type /nametype eq
      {
        dup (<<) cvn eq
        {
          pop mark
          {
            counttomark 2 add index token not {//false exit} if
            dup (>>) cvn eq {pop //true exit} if
          } loop
          { .dicttomark }{cleartomark} ifelse
        } if
      } if
      1 index type /stringtype eq
      1 index type /nametype eq and 1 index xcheck and
      1 index /run eq 2 index /.runlibfile eq or and {
                % This is an inclusion entry.
        pop findlibfile { exch pop } { file } ifelse
        2 index exch .readFontmap pop
      } {
                % This is a real entry.
                % Read and pop tokens until a semicolon.
       { 2 index token not
          { (Fontmap entry for ) print 1 index =only
            ( ends prematurely!  Giving up.) = flush
            {//.loadFontmap exec} 0 get 1 .quit
          } if
         dup /; eq { pop 3 index 3 1 roll .growput exit } if
         pop
       } loop
      } ifelse
    } loop
}.internalbind def
% Add an entry in Fontmap.  We redefine this if the Level 2
% resource machinery is loaded.
/.definefontmapaux                 % <bool> <fontname> <file|alias> .definefontmapaux -
 {              % Since Fontmap is global, make sure the values are storable.
   % If the fontname contains Unicode (first byte == \000) and
   % this is not an alias definition, define an alias using ASCII
   % (stripping out the high \000 bytes). Observed with some TT fonts.
   1 index 100 string cvs
   dup length 0 gt {
     0 get 0 eq 1 index type /nametype ne and {
       1 index 100 string cvs dup length 2 div cvi string //true exch
       0 1 2 index length 1 sub {
         % stack: fontname filename fontnamestring addflag newstring index
         dup 4 index exch 2 mul get 0 ne {
           % High byte of pair is not \000
           pop pop //false exch
           exit
         } if
         dup 4 index exch 2 mul 1 add get 2 index 3 1 roll put
       } for
       exch {
         DEBUG { (\nAdding alias for: ) print 1 index ==only ( as: ) print dup //== exec flush } if
           cvn exch cvn .definefontmapaux	% recurse with an alias
       } {
         pop pop	% discard the name
       } ifelse
     } if
   } {
     pop
   } ifelse
   .currentglobal 3 1 roll //true .setglobal
   dup type /stringtype eq
    { dup .gcheck not { dup length string copy } if
    }
   if

   4 -1 roll {.nativeFontmap}{Fontmap} ifelse
   3 -1 roll 2 copy .knownget
    {           % Add an element to the end of the existing value,
                % unless it's the same as the current last element.
      mark exch aload pop counttomark 4 add -1 roll
      2 copy eq { cleartomark pop pop } { ] readonly .growput } ifelse
    }
    {           % Make a new entry.
      mark 4 -1 roll ] readonly .growput
    }
   ifelse .setglobal
 }.internalbind def

/.definefontmap                 % <fontname> <file|alias> .definefontmap -
{
  //false 3 1 roll //.definefontmapaux exec
}.internalbind def

/.definenativefontmap                 % <fontname> <file|alias> .definenativefontmap -
{
  //true 3 1 roll //.definefontmapaux exec
}.internalbind def

% Parse a font file just enough to find the FontName or FontType.
/.findfontvalue {       % <file> <key> .findfontvalue <value> true
                        % <file> <key> .findfontvalue false
                        % Closes the file in either case.
  exch dup read {
    2 copy .unread 16#80 eq {
      dup (xxxxxx) readstring pop pop             % skip .PFB header
    } if
    {           % Stack: key file
                % Protect ourselves against syntax errors here.
      dup { token } stopped { //false exit } if
      not { //false exit } if               % end of file
      dup /eexec eq { pop //false exit } if       % reached eexec section
      dup /Subrs eq { pop //false exit } if       % Subrs without eexec
      dup /CharStrings eq { pop //false exit } if % CharStrings without eexec
      dup 3 index eq
       { xcheck not { dup token exit } if }       % found key
       { pop }
      ifelse
    } loop
                % Stack: key file value true   (or)
                % Stack: key file false
    dup { 4 } { 3 } ifelse -2 roll closefile pop
  } { closefile pop //false } ifelse
}.internalbind def
/.findfontname
 { /FontName .findfontvalue
 }.internalbind def

% If there is no FONTPATH, try to get one from the environment.
NOFONTPATH { /FONTPATH () def } if
/FONTPATH where
 { pop }
 { /FONTPATH (GS_FONTPATH) getenv not { () } if def }
ifelse

% The following are dummy definitions that, if we have a FONTPATH, will
% be replaced in the following section.
% They are here so immediately evaulation will work, and allow them to
% undefined at the bottom of the file.
/.scanfontbegin{}.internalbind def
/.scanfontdir {}.internalbind def

FONTPATH length 0 eq { (%END FONTPATH) .skipeof } if
/FONTPATH [ FONTPATH .pathlist ] def

FONTPATH
{
    /PermitFileReading exch .addcontrolpath
} forall

% Scan directories looking for plausible fonts.  "Plausible" means that
% the file begins with %!PS-AdobeFont or %!FontType1, or with \200\001
% followed by four arbitrary bytes and then either of these strings.
% To speed up the search, we skip any file whose name appears in
% the Fontmap (with any extension and upper/lower case variation) already,
% and any file whose extension definitely indicates it is not a font.
%
% NOTE: The current implementation of this procedure is somewhat Unix/DOS-
% specific.  It assumes that '/' and '\' are directory separators, and that
% the part of a file name following the last '.' is the extension.
%
/.lowerstring           % <string> .lowerstring <lowerstring>
 { 0 1 2 index length 1 sub
    { 2 copy get dup 65 ge exch 90 le and
       { 2 copy 2 copy get 32 add put }
     if pop
    }
   for
 }.internalbind def
/.splitfilename {       % <dir.../base.extn> .basename <base> <extn>
                % Make the file name read-only to detect aliasing bugs.
                % We really don't like doing this, but we've had one
                % such bug already.
  readonly {
    (/) search { //true } { (\\) search } ifelse { pop pop } { exit } ifelse
  } loop
  dup { (.) search { pop pop } { exit } ifelse } loop
  2 copy eq {
    pop ()
  } {
    exch dup length 2 index length 1 add sub 0 exch getinterval exch
  } ifelse
}.internalbind def
/.scanfontdict 1 dict def               % establish a binding
/.scanfontbegin
 {      % Construct the table of all file names already in Fontmap.
   currentglobal //true setglobal
   //.scanfontdict dup maxlength Fontmap length 2 add .max .setmaxlength
   Fontmap
    { exch pop
       { dup type /stringtype eq
          { //.splitfilename exec pop //.fonttempstring copy //.lowerstring exec cvn
            //.scanfontdict exch //true put
          }
          { pop
          }
         ifelse
       }
      forall
    }
   forall
   setglobal
 }.internalbind def
/.scanfontskip mark
                % Strings are converted to names anyway, so....
  /afm //true
  /bat //true
  /c   //true
  /cmd //true
  /com //true
  /dir //true
  /dll //true
  /doc //true
  /drv //true
  /exe //true
  /fon //true
  /fot //true
  /h   //true
  /o   //true
  /obj //true
  /pfm //true
  /pss //true           % Adobe Multiple Master font instances
  /txt //true
.dicttomark def
/.scan1fontstring 8192 string def
% BeginFont: is not per Adobe documentation, but a few fonts have it.
/.scanfontheaders [(%!PS-Adobe*) (%!FontType*) (%%BeginFont:*)] def
0 /.scanfontheaders .systemvar { length .max } forall 6 add % extra for PFB header
/.scan1fontfirst exch string def
/.scanfontdir           % <dirname> .scanfontdir -
 { currentglobal exch //true setglobal
   QUIET not { (Scanning ) print dup print ( for fonts...) print flush } if
   [ 1 index ] (*) .generate_dir_list_templates
   0 0 0 4 -1 roll      % found scanned files
    {           % stack: <fontcount> <scancount> <filecount> <filename>
      exch 1 add exch                   % increment filecount
      dup //.splitfilename exec //.fonttempstring copy //.lowerstring exec
                % stack: <fontcount> <scancount> <filecount+1> <filename>
                %       <BASE> <ext>
      //.scanfontskip exch known exch //.scanfontdict exch known or
       { pop
                % stack: <fontcount> <scancount> <filecount+1>
       }
       { 3 -1 roll 1 add 3 1 roll
                % stack: <fontcount> <scancount+1> <filecount+1> <filename>
         dup (r) { file } //.internalstopped exec
          { pop pop //null ()
                % stack: <fontcount> <scancount+1> <filecount+1> <filename>
                %       null ()
          }
          {
                % On some platforms, the file operator will open directories,
                % but an error will occur if we try to read from one.
                % Handle this possibility here.
            dup //.scan1fontfirst { readstring } //.internalstopped exec
             { pop pop () }
             { pop }
            ifelse
                % stack: <fontcount> <scancount+1> <filecount+1>
                %       <filename> <file> <header>
          }
         ifelse
                % Check for PFB file header.
         dup (\200\001????*) .stringmatch
          { dup length 6 sub 6 exch getinterval }
         if
                % Check for font file headers.
         //false /.scanfontheaders .systemvar
          { 2 index exch .stringmatch or
          }
         forall exch pop
          {     % stack: <fontcount> <scancount+1> <filecount+1> <filename>
                %       <file>
            dup 0 setfileposition //.findfontname exec
             { dup .nativeFontmap exch known
                { pop pop
                }
                { exch
                  dup length string copy % copy string
                  exch
                  DEBUG { ( ) print dup =only flush } if
                  1 index //.definenativefontmap exec
                  //.splitfilename exec pop //true //.scanfontdict 3 1 roll .growput
                        % Increment fontcount.
                  3 -1 roll 1 add 3 1 roll
                }
               ifelse
             }
             { pop
             }
            ifelse
          }
                % .findfontname will have done a closefile in the above case.
          { dup //null eq { pop } { closefile } ifelse pop
          }
         ifelse
       }
      ifelse
    }
   //.scan1fontstring filenameforall
   QUIET
    { pop pop pop }
    { ( ) print =only ( files, ) print =only ( scanned, ) print
      =only ( new fonts.) = flush
    }
   ifelse
   pop
   setglobal
 }.internalbind def

%END FONTPATH

/FONTMAP where
{
  dup /FONTMAP get /FONTMAP exch [ exch //.pathlist exec] put
  /FONTMAP dup where pop exch get {/PermitFileReading exch .addcontrolpath} forall
} if

% Try to enumerate native fonts registered with the os
% and add them to the fontmap. This relies on a custom
% operator which calls platform-specific C code. It
% returns an array of arrays, each containing a pair
% of strings: what the system thinks is the ps name,
% and the access path.
/.setnativefontmapbuilt { % set whether we've been run
  dup type /booleantype eq {
      systemdict exch /.nativefontmapbuilt exch .forceput
  } executeonly
  {pop}
  ifelse
} .forcebind odef
systemdict /NONATIVEFONTMAP known .setnativefontmapbuilt
/.buildnativefontmap {   % - .buildnativefontmap <bool>
  systemdict /.nativefontmapbuilt .knownget not
  { //false} if

  {//false}
  {
    QUIET not {
      (Querying operating system for font files...\n)
      print flush
    } if
    .getnativefonts dup
    {
      exch
      {
        % stack: [ (name) (path) ]
        % verify the font name ourselves
        dup 1 get (r) { file } //.internalstopped exec
        {
          % skip the entry if we can't open the returned path
          pop pop pop
        }{
          % we could open the font file
          mark 2 1 roll
          {//.findfontname exec} //.internalstopped exec
          {
            cleartomark
            pop
          }
          {
            counttomark 1 add -1 roll pop
            not { dup 0 get } if  % stack: (newname) [ (name) (path) ]
            % DEBUG { (  found ) print dup print (\n) print flush } if
            % add entry to the fontmap
            1 index exch 0 exch dup type /nametype ne {cvn} if put
            aload pop //.definenativefontmap exec
          } ifelse
        } ifelse
      } forall
    } if
    % record that we've been run
    //true //.setnativefontmapbuilt
  } ifelse
}.internalbind odef

% Create the dictionary that registers the .buildfont procedure
% (called by definefont) for each FontType.
/buildfontdict 20 dict def

% Register Type 3 fonts, which are always supported, for definefont.
buildfontdict 3 /.buildfont3 cvx put

% Register Type 0 fonts if they are supported.  Strictly speaking,
% we should do this in its own file (gs_type0.ps), but since this is
% the only thing that would be in that file, it's simpler to put it here.
/.buildfont0 where { pop buildfontdict 0 /.buildfont0 cvx put } if

% Define definefont. This is a procedure built on a set of operators
% that do all the error checking and key insertion.
/.growfontdict
 {      % Grow the font dictionary, if necessary, to ensure room for an
        % added entry, making sure there is at least one slot left for FID.
   dup maxlength 1 index length sub 2 lt
    { dup dup wcheck
       { //.growdict exec}
       { //.growdictlength exec dict .copydict }
      ifelse
    }
    { dup wcheck not { dup maxlength dict .copydict } if
    }
   ifelse
 }.internalbind def
/.completefont {
  {             % Check for disabled platform fonts.
      NOPLATFONTS
       {        % Make sure we leave room for FID.
         //.growfontdict exec dup /ExactSize 0 put
       }
       {        % Hack: if the Encoding looks like it might be the
                % Symbol or Dingbats encoding, load those now (for the
                % benefit of platform font matching) just in case
                % the font didn't actually reference them.
                % Note that some types of font don't have an Encoding.
         dup /Encoding .knownget {
           dup length 65 ge {
             64 get
             dup /congruent eq { SymbolEncoding pop } if
             /a9 eq { DingbatsEncoding pop } if
           } {
             pop
           } ifelse
         } if
       }
      ifelse
      dup /OrigFont known not {
        dup dup /OrigFont exch .growput
      } if
      //true exch
                % If this is a CIDFont, CIDFontType takes precedence
                % over FontType.
      dup /CIDFontType known {
        /.buildcidfont where {
          pop exch not exch     % true => false
        } if
      } if
      exch {
        dup /FontType get //buildfontdict exch get
      } {
        {.buildcidfont}		% so it gets bound
      } ifelse
  } stopped { $error /command get /invalidfont signalerror } if

      % Execute the .buildxxxfontx outside the 'stopped', because we don't
      % want its errors converted to invalidfont.
      exec

  {
      systemdict /ProvideUnicode .knownget not { //false } if {
        /FontEmulationProcs /ProcSet findresource
        /ProvideUnicodeDecoding get exec
      } if
      readonly          % stack: name fontdict
  } stopped { $error /command get /invalidfont signalerror } if
}.internalbind odef
/definefont
 { dup rcheck not {
      /definefont cvx /invalidaccess signalerror
   } if
   /definefont cvx {.completefont} .errorexec
                % If the current allocation mode is global, also enter
                % the font in LocalFontDirectory.
   .currentglobal
    { //systemdict /LocalFontDirectory .knownget
       { 2 index 2 index .forceput }	% readonly
      if
    }
   if
   dup //.FontDirectory 4 -2 roll .forceput % readonly
                % If the font originated as a resource, register it.
   currentfile .currentresourcefile eq { dup .registerfont } if
   readonly
 } .forcebind odef

% Define a procedure for defining aliased fonts.
% We use this only for explicitly aliased fonts, not substituted fonts:
% we think this matches the observed behavior of Adobe interpreters.
/.aliasfont             % <name> <font> .aliasfont <newFont>
 {
   currentglobal 3 1 roll dup gcheck setglobal
                             % <bool> <name> <font>
   dup length 2 add dict     % <bool> <name> <font> <dict>
   dup 3 -1 roll             % <bool> <name> <dict> <dict> <font>
   { 1 index /FID eq { pop pop } { put dup } ifelse } forall
                             % <bool> <name> <dict> <dict>
                % Stack: global fontname newfont newfont.
                % We might be defining a global font whose FontName
                % is a local string.  This is weird, but legal,
                % and doesn't cause problems anywhere else:
                % to avoid any possible problems in this case, do a cvn.
                % We might also be defining (as an alias) a global font
                % whose FontName is a local non-string, if someone passed a
                % garbage value to findfont.  In this case, just don't
                % call definefont at all.
    2 index dup type /stringtype eq exch gcheck or 1 index gcheck not or
    { pop                              % <bool> <name> <dict>
      1 index dup type /stringtype eq { cvn } if
                                       % <bool> <name> <dict> <name1>
           % HACK:
           % We want to know whether we alias a font,
           % because in this case its FontName to be replaced with the alias.
           % There is no simple way to know that at this point.
           % But if the original font has defaultfontname,
           % we probably substitute it rather than alias.
           % Using such condition as an approximation to the strong condition.
           %
           % Note it works wrongly if Fontmap maps something to defaultfontname like this :
           %        /Courier  /NimbusMonL-Regu	;
           %        /Something /Courier ;
           % The FontName of Something will not be /Something. It will be /Courier .
           %
      1 index /FontName get defaultfontname ne {
        2 copy /FontName exch put
      } if
      1 index exch /.Alias exch put    % <bool> <name> <dict>
      dup dup /OrigFont exch .growput
                % Don't bind in definefont, since Level 2 redefines it.
      /definefont .systemvar exec
    }
    {
      /findfont cvx {.completefont} //.errorexec exec pop exch pop
    }
   ifelse
   exch setglobal
 }.internalbind odef         % so findfont will bind it

% Define .loadfontfile for loading a font.  If we recognize Type 1 and/or
% TrueType fonts, gs_type1.ps and/or gs_ttf.ps will redefine this.
/.loadfontfile {
                % According to Ed Taft, Adobe interpreters push userdict
                % before loading a font, and pop it afterwards.
  userdict begin
    cvx exec
  end
}.internalbind def
/.setloadingfont {
   //systemdict /.loadingfont 3 -1 roll .forceput
} .forcebind odef % .forceput must be bound and hidden
/.loadfont
 {              % Some buggy fonts leave extra junk on the stack,
                % so we have to make a closure that records the stack depth
                % in a fail-safe way.
   //true .setloadingfont
   { /FAPI_hook_disable pop % gs_fapi accesses this with execstack_lookup - don't remove !
     {{.loadfontfile} .execasresource} count 1 sub 2 .execn
     count exch sub { pop } repeat
     exit
   } loop % this loop is a pattern for execstack_lookup, don't remove !
   //false .setloadingfont
 }.internalbind def

% Find an alternate font to substitute for an unknown one.
% We go to some trouble to parse the font name and extract
% properties from it.  Later entries take priority over earlier.
/.substitutefaces [
        % Define substitutes for the fonts we define in Fontmap.GS
  [(Charter) /Times 0]
  [(Utopia) /Times 0]
  [(Antiqua) /Times 0]
  [(Calligraphic) /Helvetica 0]
  [(Hershey) /Times 0]
        % Guess at suitable substitutions for random unknown fonts.
  [(Book) /NewCenturySchlbk 0]
  [(Grot) /Helvetica 0]
  [(Roman) /Times 0]
  [(Chancery) /ZapfChancery-MediumItalic 0]
        % If the family name appears in the font name,
        % use a font from that family.
  [(Arial) /Helvetica 0]
  [(Avant) /AvantGarde 0]
  [(Bookman) /Bookman 0]
  [(Century) /NewCenturySchlbk 0]
  [(Cour) /Courier 0]
  [(Frut) /Helvetica 0]
  [(Garamond) /Palatino 0]
  [(Geneva) /Helvetica 0]
  [(Helv) /Helvetica 0]
  [(NewYork) /Bookman 0]
  [(Pala) /Palatino 0]
  [(Schlbk) /NewCenturySchlbk 0]
  [(Swiss) /Helvetica 0]
  [(Symbol) /Symbol 0]
  [(Times) /Times 0]
        % Substitute for Adobe Multiple Master fonts.
  [(Minion) /Times 0]
  [(Myriad) /Helvetica 0]
        % If the font wants to be monospace, use Courier.
  [(Monospace) /Courier 0]
  [(Typewriter) /Courier 0]
        % Define substitutes for the other Adobe PostScript 3 fonts.
        % For some of them, the substitution is pretty bad!
  [(Albertus) /Palatino 0]
  [(AntiqueOlive) /Helvetica 0]
  [(Bodoni) /NewCenturySchlbk 0]
  [(Chicago) /Helvetica 2]
  [(Clarendon) /Bookman 0]
  [(Cooper) /NewCenturySchlbk 0]
  [(Copperplate) /AvantGarde 0] % inappropriate, small-cap font
  [(Coronet) /ZapfChancery-MediumItalic 0]
  [(Eurostile) /Helvetica 0]
  [(Geneva) /Courier 2]         % should be fixed-pitch sans demi
  [(GillSans) /Helvetica 2]
  [(GillSans-Light) /Helvetica 0]
  [(Goudy) /Palatino 0]
  [(Hoefler) /NewCenturySchlbk 0]
  [(Joanna) /Times 0]
  [(LetterGothic) /Courier 0]   % should be fixed-pitch sans
  [(LubalinGraph-Book) /Bookman 2]
  [(LubalinGraph-Demi) /Bookman 0]
  [(Marigold) /ZapfChancery-MediumItalic 0]
  [(MonaLisa-Recut) /Palatino 0]        % inappropriate
  [(Monaco) /Courier 2]         % should be fixed-pitch sans demi
  [(Optima) /Helvetica 0]
  [(Oxford) /ZapfChancery-MediumItalic 0]
  [(Tekton) /Helvetica 0]
  [(Univers) /Helvetica 0]
] readonly def
/.substituteproperties [
  [(It) 1] [(Oblique) 1]
  [(Black) 2] [(Bd) 2] [(Bold) 2] [(bold) 2] [(Demi) 2] [(Heavy) 2] [(Sb) 2]
  [(Cn) 4] [(Cond) 4] [(Narrow) 4] [(Pkg) 4] [(Compr) 4]
  [(Serif) 8] [(Sans) -8]
] readonly def

/.fontnamestring {              % <fontname> .fontnamestring <string|name>
  dup type dup /nametype eq {
    pop .namestring
  } {
    /stringtype ne { pop () } if
  } ifelse
}.internalbind def

/.fontnameproperties {          % <int> <string|name> .fontnameproperties
                                %   <int'>
  //.fontnamestring exec
  //.substituteproperties {
    2 copy 0 get search {
      pop pop pop dup length 1 sub 1 exch getinterval 3 -1 roll exch {
        dup 0 ge { or } { neg not and } ifelse
      } forall exch
    } {
      pop pop
    } ifelse
  } forall pop
}.internalbind def
/.substitutefamilies mark
  /AvantGarde
    {/AvantGarde-Book /AvantGarde-BookOblique
     /AvantGarde-Demi /AvantGarde-DemiOblique}
  /Bookman
    {/Bookman-Demi /Bookman-DemiItalic /Bookman-Light /Bookman-LightItalic}
  /Courier
    {/Courier /Courier-Oblique /Courier-Bold /Courier-BoldOblique}
  /Helvetica
    {/Helvetica /Helvetica-Oblique /Helvetica-Bold /Helvetica-BoldOblique
     /Helvetica-Narrow /Helvetica-Narrow-Oblique
     /Helvetica-Narrow-Bold /Helvetica-Narrow-BoldOblique}
  /NewCenturySchlbk
    {/NewCenturySchlbk-Roman /NewCenturySchlbk-Italic
     /NewCenturySchlbk-Bold /NewCenturySchlbk-BoldItalic}
  /Palatino
    {/Palatino-Roman /Palatino-Italic /Palatino-Bold /Palatino-BoldItalic}
  /Symbol
    {/Symbol /Symbol /Symbol /Symbol}
  /Times
    {/Times-Roman /Times-Italic /Times-Bold /Times-BoldItalic}
  /ZapfChancery-MediumItalic
    {/ZapfChancery-MediumItalic}
.dicttomark readonly def
/.nametostring {                % <name> .nametostring <string>
                                % <other> .nametostring <other>
  dup type /nametype eq { .namestring } if
}.internalbind def

/.substitutefontname {          % <fontname> <properties> .substitutefontname
                                %   <altname|null>
        % Look for properties and/or a face name in the font name.
        % If we find any, use Times (serif) or Helvetica (sans) as the
        % base font; otherwise, use the default font.
        % Note that the "substituted" font name may be the same as
        % the requested one; the caller must check this.
  exch //.fontnamestring exec {
    defaultfontname /Helvetica-Oblique /Helvetica-Bold /Helvetica-BoldOblique
    /Helvetica-Narrow /Helvetica-Narrow-Oblique
    /Helvetica-Narrow-Bold /Helvetica-Narrow-BoldOblique
    /Times-Roman /Times-Italic /Times-Bold /Times-BoldItalic
    /Helvetica-Narrow /Helvetica-Narrow-Oblique
    /Helvetica-Narrow-Bold /Helvetica-Narrow-BoldOblique
  } 3 1 roll
        % Stack: facelist properties fontname
        % Look for a face name.
  //.substitutefaces {
    2 copy 0 get search {
      pop pop pop
        % Stack: facelist properties fontname [(pattern) family properties]
      dup 2 get 4 -1 roll or 3 1 roll
      1 get //.substitutefamilies exch get
      4 -1 roll pop 3 1 roll
    } {
      pop pop
    } ifelse
  } forall pop
  1 index length mod get exec
}.internalbind odef
/.substitutefont {              % <fontname> .substitutefont <altname>
  dup 0 exch //.fontnameproperties exec .substitutefontname
        % Only accept fonts known in the Fontmap.
   Fontmap 1 index known not
   {
     .nativeFontmap 1 index known not
     {pop defaultfontname } if
   } if
}.internalbind odef

% If requested, make (and recognize) fake entries in FontDirectory for fonts
% present in Fontmap but not actually loaded.  Thanks to Ray Johnston for
% the idea behind this code.
FAKEFONTS not { (%END FAKEFONTS) .skipeof } if

% We use the presence or absence of the FontMatrix key to indicate whether
% a font is real or fake.  We must pop the arguments at the very end,
% so that stack protection will be effective.

/definefont {           % <name> <font> definefont <font>
  dup /FontMatrix known {
    //definefont
  } {
    2 copy /FontName get findfont //definefont exch pop exch pop
  } ifelse
}.internalbind odef

/scalefont {            % <font> <scale> scalefont <font>
  1 index /FontMatrix known {
    //scalefont
  } {
    1 index /FontName get findfont 1 index //scalefont
    exch pop exch pop
  } ifelse
}.internalbind odef

/makefont {             % <font> <matrix> makefont <font>
  1 index /FontMatrix known {
    //makefont
  } {
    1 index /FontName get findfont 1 index //makefont
    exch pop exch pop
  } ifelse
}.internalbind odef

/setfont {              % <font> setfont -
  dup /FontMatrix known {
    //setfont
  } {
    dup /FontName get findfont //setfont pop
  } ifelse
}.internalbind odef

%END FAKEFONTS

% Define findfont so it tries to load a font if it's not found.
% The Red Book requires that findfont be a procedure, not an operator,
% but it still needs to restore the stacks reliably if it fails,
% so we do all the work in an operator.
/.findfont {             % <fontname> .findfont <font>
  mark 1 index        % <fontname> mark <fontname>
  //systemdict begin .dofindfont
                      % <fontname> mark <alias> ... <font>
        % Define any needed aliases.
  counttomark 1 sub { .aliasfont } repeat end
                      % <fontname> mark <font>
  exch pop exch pop
}.internalbind odef
/findfont {
  .findfont
}.internalbind def
% Check whether the font name we are about to look for is already on the list
% of aliases we're accumulating; if so, cause an error.
/.checkalias            % -mark- <alias1> ... <name> .checkalias <<same>>
 { counttomark 1 sub -1 1
    { index 1 index eq
       { pop QUIET not
          { (Unable to substitute for font.) = flush
          } if
         /findfont cvx /invalidfont signalerror
       }
      if
    }
   for
 }.internalbind def
% Get a (non-fake) font if present in a FontDirectory.
/.fontknownget          % <fontdir> <fontname> .fontknownget <font> true
                        % <fontdir> <fontname> .fontknownget false
 { .knownget
    { FAKEFONTS
       { dup /FontMatrix known { //true } { pop //false } ifelse }
       { //true }
      ifelse
    }
    { //false
    }
   ifelse
 }.internalbind def
% This is the standard procedure for handling font substitution.
% Its location is per an Adobe newsgroup posting.
% It is called with the font name on the stack, standing in for findfont.
/.stdsubstfont {        % mark <alias1> ... <fontname> .stdsubstfont mark <alias1> ... <aliasN> <font>
      /SUBSTFONT where {
        pop QUIET not {
          (Substituting for font ) print dup =only
          (.) = flush
        } if
                        % No aliasing.
                        % This mode is incompatible with high level devices.
        defaultfontname /None eq { /findfont cvx /invalidfont signalerror } if
        cleartomark mark defaultfontname
      } {
        dup .substitutefont
        2 copy eq {
          defaultfontname /None eq { /findfont cvx /invalidfont signalerror } if
          pop defaultfontname
        } if
        //.checkalias exec
        QUIET not {
          SHORTERRORS {
            (%%[) print 1 index =only
            ( not found, substituting ) print dup =only (]%%)
          } {
            (Substituting font ) print dup =only
            ( for ) print 1 index =only (.)
          } ifelse = flush
        } if
      } ifelse
  /Font findresource
}.internalbind def

% Default font substitution does {pop /Courier} om many implementations.
% GS post-process font substitution in .stdsubstfont and uses {} for
% backward compatibility
$error /SubstituteFont { } put

% Scan the next directory on FONTPATH.
/.scannextfontdir {     % - .scannextfontdir <bool>
                        % If we haven't scanned all the directories in
                        % FONTPATH, scan the next one.
  //null 0 1 FONTPATH length 1 sub {
    FONTPATH 1 index get //null ne { exch pop exit } if pop
  } for dup //null ne {
    dup 0 eq { //.scanfontbegin exec} if
    FONTPATH 1 index get //.scanfontdir exec
    FONTPATH exch //null put //true
  } {
    pop //false
  } ifelse
}.internalbind def
% Do the work of findfont, including substitution, defaulting, and
% scanning of FONTPATH.
/.dofindfont {   %  mark <fontname> .dofindfont % mark <alias> ... <font>
  .tryfindfont not {
                        % We didn't find the font.  If we haven't scanned
                        % all the directories in FONTPATH, scan the next one
                        % now and look for the font again.
    //.scannextfontdir exec {
                        % Start over with an empty alias list.
      counttomark 1 sub { pop } repeat    % mark <fontname>
      .dofindfont
    } {
                        % No more directories to scan. Try building the native
                        % font map entries if we haven't already done so.
        .buildnativefontmap {
                        % Same stack as at the beginning of .dofindfont.
        .dofindfont     % start over
      } {
                        % No luck.  Make sure we're not already
                        % looking for the default font.
        QUIET not {
          (Didn't find this font on the system!\n)
          print
        } if
        dup defaultfontname eq {
          QUIET not {
            (Unable to load default font ) print
            dup =only (!  Giving up.) = flush
          } if
          /findfont cvx /invalidfont signalerror
        } if
                        % Substitute for the font.  Don't alias.
                        % Same stack as at the beginning of .dofindfont.

        $error /SubstituteFont get exec
                         %
                         % igorm: I guess the surrounding code assumes that .stdsubstfont
                         % must ADD an alias to allow .checkalias and .findfont to work properly.
                         % Also I guess that a trailing recursion is
                         % used in .dofindfont and through .stdsubstfont
                         % just to represent a simple iteration,
                         % which accumulates the aliases after the mark.
        //.stdsubstfont exec
      } ifelse
    } ifelse
  } if
}.internalbind def

% any user of .putgstringcopy must use bind and executeonly
/.putgstringcopy  %   <dict> <name> <string> .putgstringcopy -
{ 2 index gcheck currentglobal
  2 copy eq {
    pop pop .forceput
  } executeonly {
    5 1 roll setglobal
    dup length string copy
    .forceput setglobal
  } executeonly ifelse
} .forcebind odef % must be bound and hidden for .forceput

/.loadfontloop {        % <fontname> <filename> <libflag> .loadfontloop
                        %   <font> true
                        % -or-
                        %   <fontname> false
                        % See above regarding the use of 'loop'.
    {                   % Is the font name a string?
        1 index type /stringtype ne
         { pop
           QUIET not
            { (Can't find font with non-string name: ) print dup =only (.) = flush
            }
           if pop //false exit
         } if

        % check <libflag>
        {
          findlibfile not
        }
        {
          //true
        } ifelse


        % if findlibfile didn't work, try just opening the file direcly.
        {
          dup (r) { file } stopped {
            pop pop //true
          } {
            //false
          } ifelse
        }
        {
          //false
        }ifelse

        % If just opening the file didn't work, try opening the file name
        % in the font resource directory
        {
          dup
          //.fonttempstring /FontResourceDir getsystemparam .genericrfn
          (r) { file } stopped {
            pop pop //true
          } {
            dup .filename
            { 3 -1 roll pop exch }
            { pop }
            ifelse
            //false
          } ifelse
        }
        {
          //false
        }ifelse

        {
          QUIET not
            { (Can't find \(or can't open\) font file ) print dup print
              (.) = flush
            }
           if pop //false exit
        } if
                         % Stack: fontname fontfilename fontfile
        QUIET not
         { (Loading ) print 2 index =only
           ( font from ) print 1 index print (... ) print flush
         }
        if
        % If LOCALFONTS isn't set, load the font into local or global
        % VM according to FontType; if LOCALFONTS is set, load the font
        % into the current VM, which is what Adobe printers (but not
        % DPS or CPSI) do.
        LOCALFONTS { //false } { /setglobal where } ifelse
         { pop /FontType .findfontvalue { 1 eq } { //false } ifelse
                % .setglobal, like setglobal, aliases FontDirectory to
                % GlobalFontDirectory if appropriate.  However, we mustn't
                % allow the current version of .setglobal to be bound in,
                % because it's different depending on language level.
           .currentglobal exch /.setglobal .systemvar exec
                % Remove the fake definition, if any.
           //.FontDirectory 3 index .forceundef		% readonly
           1 index (r) file .loadfont //.FontDirectory exch
           /.setglobal .systemvar exec
         } executeonly
         { .loadfont //.FontDirectory
         }
        ifelse
                % Stack: fontname fontfilename fontdirectory
        QUIET not
         { //systemdict /level2dict known
            { .currentglobal //false .setglobal vmstatus
              //true .setglobal vmstatus 3 -1 roll pop
              6 -1 roll .setglobal 5
            }
            { vmstatus 3
            }
           ifelse { =only ( ) print } repeat
           (done.) = flush
         } if

                % Check to make sure the font was actually loaded.
        dup 3 index //.fontknownget exec
         { dup /PathLoad 4 index //.putgstringcopy
           4 1 roll pop pop pop //true exit
         } executeonly if

                % Maybe the file had a different FontName.
                % See if we can get a FontName from the file, and if so,
                % whether a font by that name exists now.
        exch dup      % Stack: origfontname fontdirectory path path
        (r) file //.findfontname exec
         {            % Stack: origfontname fontdirectory path filefontname
           2 index 1 index //.fontknownget exec
            {   % Yes.  Stack: origfontname fontdirectory path filefontname fontdict
              dup 4 -1 roll /PathLoad exch //.putgstringcopy
                      % Stack: origfontname fontdirectory filefontname fontdict
              3 -1 roll pop
                      % Stack: origfontname filefontname fontdict
              dup /FontName get dup //.FontDirectory exch .forceundef
              /GlobalFontDirectory .systemvar exch .forceundef
              dup length dict .copydict dup 3 index /FontName exch put
              2 index exch definefont
              exch
              QUIET
               { pop
               }
               { (Using ) print =only
                 ( font for ) print 1 index =only
                 (.) = flush
               }
              ifelse  % Stack: origfontname fontdict
              exch pop //true exit
                      % Stack: fontdict
            } executeonly
           if pop % Stack: origfontname fontdirectory path
         } executeonly
        if pop pop  % Stack: origfontname

                % The font definitely did not load correctly.
        QUIET not
         { (Loading ) print dup =only
           ( font failed.) = flush
         } if
        //false exit

    } loop              % end of loop

 }.internalbind def % must be bound and hidden for .putgstringcopy

% Attempt to load a font from a file.
/.tryloadfont {         % <fontname> .tryloadfont <font> true
                        % <fontname> .tryloadfont false
  dup //.nametostring exec
                % Hack: check for the presence of the resource machinery.
  /.genericrfn where {
    pop
    pop dup //.fonttempstring /FontResourceDir getsystemparam .genericrfn
    {//false //.loadfontloop exec} //.internalstopped exec {//false} if {
      //true
    } {
      dup //.nametostring exec
      {//true //.loadfontloop exec} //.internalstopped exec {//false} if
    } ifelse
  } {
    {//true //.loadfontloop exec} //.internalstopped exec {//false} if
  } ifelse
}.internalbind def

% Try to find a font using only the present contents of Fontmap.
/.tryfindfont {         % <fontname> .tryfindfont <font> true
                        % <fontname> .tryfindfont false
  //.FontDirectory 1 index //.fontknownget exec
    {                   % Already loaded
      exch pop //true
    }
    {
       dup Fontmap exch .knownget
       { //true //true }
       {                % Unknown font name.  Look for a file with the
                        % same name as the requested font.
         dup //.tryloadfont exec
         { exch pop //true //false }
         {
           % if we can't load by name check the native font map
           .nativeFontmap exch .knownget
           { //true //true }
           { //false //false } ifelse
         } ifelse
       } ifelse

       {                % Try each element of the Fontmap in turn.
         pop
         //false exch   % (in case we exhaust the list)
                        % Stack: fontname false fontmaplist
         { exch pop
           dup type /nametype eq
            {                   % Font alias
              //.checkalias exec
              dup .tryfindfont
              {
                % We don't want to reuse an embedded font as a substitute
                % so make sure the font came from disk before using it.
                dup /Path known
                1 index /PathLoad known or
                { exch pop //true exit }
                {
                  % if the candidate didn't come from disk, remove it from
                  % FontDirectory and try again.
                  pop dup undefinefont
                  .tryfindfont exit
                }
                ifelse
              } if
            }
            { dup dup type dup /arraytype eq exch /packedarraytype eq or exch xcheck and
               {                % Font with a procedural definition
                 exec           % The procedure will load the font.
                                % Check to make sure this really happened.
                 //.FontDirectory 1 index .knownget
                  { exch pop //true exit }
                 if
               }
               {                % Font file name
                 dup type /dicttype eq
                 {
                   begin
                   Path
                 }
                 {
                   1 dict begin
                 } ifelse
                 //true //.loadfontloop exec
                 end
                 { //true exit } if
               }
              ifelse
            }
           ifelse //false
         }
         forall
                        % Stack: font true -or- fontname false
         { //true
         }
         {                      % None of the Fontmap entries worked.
                                % Try loading a file with the same name
                                % as the requested font.
           //.tryloadfont exec
         }
        ifelse
       }
      if
    }
   ifelse
 }.internalbind def

% Define a procedure to load all known fonts.
% This isn't likely to be very useful.
/loadallfonts
{
  [Fontmap .nativeFontmap] { { pop findfont pop } forall } forall
}.internalbind def

% If requested, load all the fonts defined in the Fontmap into FontDirectory
% as "fake" fonts i.e., font dicts with only FontName and FontType defined.
% (We define FontType only for the sake of some questionable code in the
% Apple Printer Utility 2.0 font inquiry code.)
%
% Note that this procedure only creates fake fonts in the FontDirectory
% associated with the current VM.  This is because in multi-context systems,
% creating the fake fonts in local VM leads to undesirable complications.
/.definefakefonts
    {
    }
    {
      (gs_fonts FAKEFONTS) VMDEBUG
      [Fontmap .nativeFontmap ]
      {
        {
          pop dup type /stringtype eq { cvn } if
          //.FontDirectory 1 index known not {
            2 dict dup /FontName 3 index put
            dup /FontType 1 put
            //.FontDirectory 3 1 roll //.forceput exec % readonly
          } {
            pop
          } ifelse
        } forall
      } forall
    } executeonly	% hide .forceput
FAKEFONTS { exch } if pop def   % don't bind, .current/setglobal get redefined

% Install initial fonts from Fontmap.
/.loadinitialfonts
 { NOFONTMAP not
    { /FONTMAP where
          { pop FONTMAP
             { dup VMDEBUG findlibfile
                { exch pop //.loadFontmap exec }
                { /undefinedfilename signalerror }
               ifelse
             }
          }
          { LIBPATH
             { defaultfontmap
               //false .file_name_combine
               {
                 dup VMDEBUG
                 (r) { file } //.internalstopped exec {
                   pop pop
                   defaultfontmap_content { .definefontmap } forall
                 } {
                   //.loadFontmap exec
                 } ifelse
               } {
                 pop pop
               } ifelse
             }
          }
         ifelse forall
    }
   if
   userdict /defaultfontmap_content .undef
   //.definefakefonts exec     % current VM is global
 } def                  % don't bind, .current/setglobal get redefined

% Undef these, not needed outside this file
[
 % /.fonttempstring /.scannextfontdir - are also used in gs_res.ps, so are undefined there
 % /.scanfontheaders - used in gs_cff.ps, gs_ttf.ps
 /.loadfontloop /.tryloadfont /.findfont /.pathlist /.loadFontmap /.lowerstring
 /.splitfilename /.scanfontdict /.scanfontbegin
 /.scanfontskip /.scan1fontstring
 /.scan1fontfirst /.scanfontdir
 /.setnativefontmapbuilt /.aliasfont
 /.setloadingfont /.substitutefaces /.substituteproperties /.substitutefamilies
 /.nametostring /.fontnamestring /.checkalias /.fontknownget /.stdsubstfont
 /.putgstringcopy
 /.definenativefontmap
 /.findfontname /.addfontmappermitpaths /.splitdirname
] systemdict .undefinternalnames
