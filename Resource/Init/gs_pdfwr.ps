% Copyright (C) 2001-2024 Artifex Software, Inc.
% All Rights Reserved.
%
% This software is provided AS-IS with no warranty, either express or
% implied.
%
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
%
% Refer to licensing information at http://www.artifex.com or contact
% Artifex Software, Inc.,  39 Mesa Street, Suite 108A, San Francisco,
% CA 94129, USA, for further information.
%

% PDF writer additions to systemdict.

% This file should be included iff the pdfwrite "device" is included
% in the executable.

% ---------------- Predefined configurations ---------------- %

% These correspond to the 4 predefined settings in Acrobat Distiller 5,
% plus a "default" setting that doesn't downsample images.

mark
{ /pdfwrite finddevice pop } .internalstopped
{cleartomark (%END PDFWR) .skipeof} {cleartomark} ifelse

languagelevel 2 .setlanguagelevel

/.a2112 [2 1 1 2] readonly def
/.a1111 [1 1 1 1] readonly def
/.standardfonts [
  /Courier /Courier-Bold /Courier-Oblique /Courier-BoldOblique
  /Helvetica /Helvetica-Bold /Helvetica-Oblique /Helvetica-BoldOblique
  /Times-Roman /Times-Bold /Times-Italic /Times-BoldItalic
  /Symbol /ZapfDingbats
] readonly def

% Parameters common to all non-default configurations.
% Note that the default configuration overrides a few of these.
/.defaultImageDict mark
  /QFactor 0.9 /Blend 1
  /HSamples .a2112 /VSamples .a2112
.dicttomark readonly def
/.distillercommon mark
  /AlwaysEmbed []
  /AntiAliasColorImages //false
  /AntiAliasGrayImages //false
  /AntiAliasMonoImages //false
  /ASCII85EncodePages //false
  /AutoFilterColorImages //true
  /AutoFilterGrayImages //true
  /AutoPositionEPSFiles //true
  /Binding /Left
  /CalCMYKProfile (None)		% (U.S. Web Coated (SWOP) v2)
  /CalGrayProfile (None)		% (Dot Gain 20%)
  /CalRGBProfile (None)			% (sRGB IEC61966-2.1)
  /ColorImageDepth -1
  /ColorImageDict .defaultImageDict
  /ColorImageDownsampleThreshold 1.5
  /ColorImageFilter /DCTEncode
  /CompressPages //true
  /ConvertImagesToIndexed //true
  /DefaultRenderingIntent /Default
  /DetectBlends //true
  /DownsampleColorImages //true
  /DownsampleGrayImages //true
  /DownsampleMonoImages //true
  /EmitDSCWarnings //false
  /EncodeColorImages //true
  /EncodeGrayImages //true
  /EncodeMonoImages //true
  /EndPage -1
  /GrayImageDepth -1
  /GrayImageDict .defaultImageDict
  /GrayImageDownsampleThreshold 1.5
  /GrayImageFilter /DCTEncode
  /ImageMemory 524288
  /LockDistillerParams //false
  /MaxSubsetPct 100
  /MonoImageDepth -1
  /MonoImageDict mark
    /K -1
  .dicttomark readonly
  /MonoImageDownsampleThreshold 1.5
  /MonoImageFilter /CCITTFaxEncode
  /OffOptimizations 0
  /OPM 0
  /Optimize //true
  /ParseDSCComments //true
  /ParseDSCCommentsForDocInfo //true
  /PDFXTrimBoxToMediaBoxOffset [0 0 0 0]
  /PDFXSetBleedBoxToMediaBox //true
  /PDFXBleedBoxToTrimBoxOffset [0 0 0 0]
  /PreserveCopyPage //true
  /PreserveHalftoneInfo //false
  /sRGBProfile (None)			% (sRGB IEC61966-2.1)
  /StartPage 1
  /SubsetFonts //true
  /TransferFunctionInfo /Preserve
  /UseFlateCompression //true
  /UsePrologue //false
  /PassThroughJPEGImages //true
  /PassThroughJPXImages //true
  /PSPageOptionsWrap //true
.dicttomark readonly def

/.distillersettings mark

/default mark
  /AutoRotatePages /PageByPage
  /CannotEmbedFontPolicy /Warning
  /ColorACSImageDict .defaultImageDict
  /ColorConversionStrategy /LeaveColorUnchanged
%  /ColorImageDownsampleType
%  /ColorImageResolution
%  /CompatibilityLevel
  /CreateJobTicket //false
  /DoThumbnails //false
  /DownsampleColorImages //false	% override
  /DownsampleGrayImages //false		% override
  /DownsampleMonoImages //false		% override
  /EmbedAllFonts //true
  /GrayACSImageDict .defaultImageDict
%  /GrayImageDownsampleType
%  /GrayImageResolution
%  /MonoImageDownsampleType
%  /MonoImageResolution
  /NeverEmbed .standardfonts
  /Optimize //false			% override
  /PreserveEPSInfo //true
  /PreserveOPIComments //true
  /PreserveOverprintSettings //true
  /UCRandBGInfo /Preserve
.dicttomark readonly

/.screenACSImageDict mark
  /QFactor 0.76 /Blend 1 /ColorTransform 1
  /HSamples .a2112 /VSamples .a2112
.dicttomark readonly def
/screen mark
  /AutoRotatePages /PageByPage
%  /CalGrayProfile (None)
  /CannotEmbedFontPolicy /Warning
  /ColorACSImageDict .screenACSImageDict
  /ColorConversionStrategy /sRGB
  /ColorImageDownsampleType /Average
  /ColorImageResolution 72
  /CompatibilityLevel 1.5
  /CreateJobTicket //false
  /DoThumbnails //false
  /EmbedAllFonts //true
  /GrayACSImageDict .screenACSImageDict
  /GrayImageDownsampleType /Average
  /GrayImageResolution 72
  /MonoImageDownsampleType /Subsample
  /MonoImageResolution 300
  /NeverEmbed .standardfonts
  /PreserveEPSInfo //false
  /PreserveOPIComments //false
  /PreserveOverprintSettings //false
  /UCRandBGInfo /Remove
.dicttomark readonly

/ebook mark
  /AutoRotatePages /All
%  /CalGrayProfile (None)
  /CannotEmbedFontPolicy /Warning
  /ColorACSImageDict .screenACSImageDict
  /ColorConversionStrategy /sRGB
  /ColorImageDownsampleType /Average
  /ColorImageResolution 150
  /CompatibilityLevel 1.5
  /CreateJobTicket //false
  /DoThumbnails //false
  /EmbedAllFonts //true
  /GrayACSImageDict .screenACSImageDict
  /GrayImageDownsampleType /Average
  /GrayImageResolution 150
  /MonoImageDownsampleType /Subsample
  /MonoImageResolution 300
  /NeverEmbed .standardfonts
  /PreserveEPSInfo //false
  /PreserveOPIComments //false
  /PreserveOverprintSettings //false
  /UCRandBGInfo /Remove
.dicttomark readonly

/.printerACSImageDict mark
  /QFactor 0.4 /Blend 1 /ColorTransform 1
  /HSamples .a1111 /VSamples .a1111
.dicttomark readonly def
/printer mark
  /AutoRotatePages /None
%  /CalGrayProfile (None)
  /CannotEmbedFontPolicy /Warning
  /ColorACSImageDict .printerACSImageDict
  /ColorConversionStrategy /UseDeviceIndependentColor
  /ColorImageDownsampleType /Average
  /ColorImageResolution 300
  /CompatibilityLevel 1.7
  /CreateJobTicket //true
  /DoThumbnails //false
  /EmbedAllFonts //true
  /GrayACSImageDict .printerACSImageDict
  /GrayImageDownsampleType /Average
  /GrayImageResolution 300
  /MonoImageDownsampleType /Subsample
  /MonoImageResolution 1200
  /NeverEmbed []
  /PreserveEPSInfo //true
  /PreserveOPIComments //true
  /PreserveOverprintSettings //true
  /UCRandBGInfo /Preserve
.dicttomark readonly

/.prepressACSImageDict mark
  /QFactor 0.15 /Blend 1 /ColorTransform 1
  /HSamples .a1111 /VSamples .a1111
.dicttomark readonly def
/prepress mark
  /AutoRotatePages /None
  /CannotEmbedFontPolicy /Error
  /ColorACSImageDict .prepressACSImageDict
  /ColorConversionStrategy /LeaveColorUnchanged
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 300
  /CompatibilityLevel 1.7
  /CreateJobTicket //true
  /DoThumbnails //true
  /EmbedAllFonts //true
  /GrayACSImageDict .prepressACSImageDict
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 300
  /MonoImageDownsampleType /Subsample
  /MonoImageResolution 1200
  /NeverEmbed []
  /PreserveEPSInfo //true
  /PreserveOPIComments //true
  /PreserveOverprintSettings //true
  /UCRandBGInfo /Preserve
.dicttomark readonly

% Define distiller settings for the ps2write device and for the ps2ps2 script :
/PSL2Printer mark
  /AutoRotatePages /None
  /CannotEmbedFontPolicy /Error
  /ColorACSImageDict .prepressACSImageDict
  /ColorConversionStrategy /LeaveColorUnchanged
  /ColorImageDownsampleType /Subsample
  /ColorImageResolution 600
  /DownsampleColorImages //false
  /CompatibilityLevel 1.2 % Always 1.2 with ps2write.
  % /CreateJobTicket //true % Not sure
  /DoThumbnails //false
  /EmbedAllFonts //true
  /GrayACSImageDict .prepressACSImageDict
  /GrayImageDownsampleType /Subsample
  /GrayImageResolution 600
  /DownsampleGrayImages //false
  /MonoImageDownsampleType /Subsample
  /MonoImageResolution 1200
  /DownsampleMonoImages //false
  /NeverEmbed []
  /PreserveEPSInfo //true
  /PreserveOPIComments //true
  /PreserveOverprintSettings //true
  /UCRandBGInfo /Preserve
  /PreserveHalftoneInfo //true
  /TransferFunctionInfo /Preserve
%% Deprecated in 9.06
%%  /MaxViewerMemorySize 8000000
  /CompressPages //false
  /CompressFonts //true
  /ASCII85EncodePages //true
.dicttomark readonly

.dicttomark readonly def

% ---------------- End of predefined configurations ---------------- %

% ---------------- pdfmark and DSC processing ---------------- %

/.write_small_positive_real  % <file> <real> .write_small_positive_real -
{ % The argument must be grater than 0 and must be strongly samller than 0.1.
  % The conversion isn't simple due to the low (24 bits) precision
  % of the floating point arithmetics in Postscript.
  % For best result we first use the 1e8 factor since its binary
  % representation 101111101011110000100000000 well rounds into 14 significant
  % bits :         101111101011110000000000000 .
  1 index (.) writestring
  { dup 100000000 mul
    dup 10 mul 1 ge {
      % Will need not greater than 0.1 due to a rounding below.
      pop exit
    } if
    exch pop
    1 index (00000000) writestring
  } loop
  % Now it is not smaller than 1e-9, use simple digitizing.
  { dup 10 mul
    dup 10 mul 1 ge {
      pop exit
    } if
    exch pop
    1 index (0) writestring
  } loop
  % Now 0.01 <= n < 0.1, but rounding may give 0.1 .
  % Convert to integer with 7 digits precision :
  100000000 % precision factor 1e8       % f n r
  dup 10 idiv 3 1 roll mul 0.5 add cvi   % f r' N
  2 copy le {
    % The rounding overflows, suppress it.
    % Note it carries out an additional digit,
    % that's why we needed <0.1 above.
    pop pop (1) writestring
  } {
    % Didn't cary out, put 0.
    2 index (0) writestring
    exch                                 % f N r
    % Continue the simple digitizing :
    { 10 idiv dup                        % f N r' r'
      2 index exch idiv                  % f N r' d
      (0123456789) exch 1 getinterval    % f N r' (d)
      3 index exch writestring           % f N r'
      dup 3 2 roll exch mod              % f r' N'
      dup 0 eq {
        % Don't write trailing zeros.
        exit
      } if
      exch                               % f N' r'
    } loop
    pop pop pop
  } ifelse
} .internalbind def

% Encode values to pass for the /pdfmark or /DSC pseudo-parameter.
/.pdf===dict mark
  /arraytype
   { dup xcheck { ({) (}) } { ([) (]) } ifelse
                % Stack: file obj left right
      4 1 roll 2 index exch writestring () exch
       { exch 2 index exch writestring
         1 index exch pdf===only ( )
       }
      forall pop exch writestring
   } .internalbind
  /packedarraytype 1 index
  /dicttype
   { 1 index (<<\n) writestring
      { 2 index 3 -1 roll pdf===only 1 index ( ) writestring
        1 index exch pdf===only dup (\n) writestring
      }
     forall (>>) writestring
   } .internalbind
  /nametype {
    % If the name string includes any non-regular characters,
    % write it with two preceding and one following null character(s).
    % (Null characters in the name itself are not allowed.)
    % This non-standard escape convention is required for passing names
    % that include non-regular characters, because PostScript provides
    % no way to do this.  The pdf_scan_token procedure in the C code of
    % the pdfwrite driver is currently the only place that recognizes
    % this convention.
    % Note that \004 may be self-delimiting in gs, but is not in standard PS.
    dup .namestring (\000\004\011\012\014\015 %()/<>[]{}) .stringbreak //null ne {
      dup .namestring (\000) .stringbreak //null ne {
        1 index <000000> writestring 1 index exch write===only 1 index exch 0 write 0 write
      }{
        1 index <0000> writestring 1 index exch write===only 0 write
      }ifelse
    } {
      write===only
    } ifelse
  } .internalbind
  /realtype {
    % Prevent using floating point format - see Bug 688167.
    dup dup 0 lt { neg } if 0.01 lt {
      dup 0 eq {
        pop (0) writestring
      } {
        dup 0 lt {
          1 index (-) writestring neg
        } if
        .write_small_positive_real
      } ifelse
    } {
      write===only
    } ifelse
  } .internalbind
.dicttomark readonly def
/pdf===only {	% <file> <obj> pdf===only -
  .pdf===dict 1 index type .knownget { exec } { write===only } ifelse
} .internalbind def
/.pdfcvbuf 30 string def	% enough for most arguments
userdict /.pdfcvstring () put
/.pdfcvs {		% <obj> .pdfcvs <string>
  currentglobal exch //false .setglobal
  /.pdfcvstring () store
                % We can't handle long values yet.
  { pop dup length 0 eq { pop } {
      /.pdfcvstring .pdfcvstring 3 -1 roll concatstrings store
    } ifelse //.pdfcvbuf
  } /NullEncode filter dup 3 -1 roll pdf===only
  closefile
  .setglobal .pdfcvstring
} .internalbind def

% Redefine pdfmark to pass the data to the driver.
% We use a pseudo-parameter named /pdfmark whose value is an array:
%	/key1 (value1) ... (CTM) /type
/.pdfputparams {	% -mark- <key1> <value1> ... .pdfputparams <result...>
  currentdevice //null //false counttomark 1 add 3 roll
                % Don't allow the page device to get cleared....
  {.putdeviceparams} .currentpagedevice pop {.setpagedevice} 3 .execn
} .internalbind def
% Convert relevant operands to strings in an array.
/.pdfcvsloop {		% -mark- values ... markname start step .pdfcvsloop
                        %   [values ... ctm markname]
   matrix currentmatrix .pdfcvs 4 1 roll
   counttomark 1 add 2 roll
   counttomark .localvmarray astore exch pop
   3 1 roll
                        % Stack: values start step
   2 index length 3 sub { 2 copy 2 copy get .pdfcvs put pop } for
} .internalbind def
/.pdfcvsall {		% -mark- values ... markname .pdfcvsall <<same>>
  0 1 .pdfcvsloop
} .internalbind def
/.pdfcvseven {		% -mark- key value ... markname .pdfcvseven <<same>>
  1 2 .pdfcvsloop
} .internalbind def
/.pdfcvsnone {		% -mark- values ... markname .pdfcvsnone <<same>>
  100000 1 .pdfcvsloop
} .internalbind def
/.pdfcvsfirst {		% -mark- first values ... markname .pdfcvsfirst<<same>>
  .pdfcvsnone
  dup 0 2 copy get .pdfcvs put
} .internalbind def
% The procedures in the following dictionary are called with the entire
% pdfmark operand list (including the pdfmark name) on the stack;
% they may modify this ad lib.  They must call .pdfcvsxxx.
/.pdfmarkparams mark
        % Unpack a dictionary for PUT, and don't convert stream data.
  /PUT {
    counttomark 3 eq {
      1 index type /dicttype eq {
        pop { } forall /.PUTDICT .pdfcvsall
      } {
        pop dup type /filetype eq {
                % Read the file into a sequence of strings.
                % This isn't great, but it's simple.
          {
            dup 64000 string readstring not { exch exit } if
            exch
          } loop closefile
        } if
        /.PUTSTREAM .pdfcvsfirst
      } ifelse
    } {
      .pdfcvsall
    } ifelse
  } .internalbind
        % Unpack the array for PUTINTERVAL.
  /PUTINTERVAL {
    pop aload pop /.PUTINTERVAL .pdfcvsall
  } .internalbind
.dicttomark readonly def
/.pdfparamerror {	% ? ? ? -mark- ... <errname> <opname> .pdfparamerror -
    counttomark 4 add 2 roll cleartomark pop pop pop
    .systemvar exch signalerror
} .internalbind def

/.CountLeafs {
  0 exch
  {
    oforce dup type /dicttype eq {
      /Limits knownoget {
        dup type /arraytype eq {
          1 get 2 copy lt {
            exch pop
          }{
            pop
          }ifelse
        }{
          (invalid number tree, /Limits not an array\n) print
          pop pop 0 exit
        } ifelse
      }{
        (invalid number tree, /Limits not defined in intermediate or leaf node\n) print
        pop pop 0 exit
      }ifelse
    } {
      (invalid number tree, /Kids entry not a dictionary\n) print
      pop pop 0 exit
    } ifelse
  } forall
} .internalbind def

/.ExtractLeafs
{
  {
    oforce dup /Nums knownoget {
      exch pop
      dup length 1 sub 0 2 3 -1 roll {
                          %% dict array index
        dup               %% dict array index index
        2 index exch get  %% dict array index
        20 string cvs cvn %% dict array index name
        exch 1 add        %% dict array name index+1
        2 index exch oget %% dict array name object
        3 index           %% dict array name object dict
        3 1 roll          %% dict array dict name object
        put               %% dict array
      } for
      pop               %% array
    }{
      /Kids knownoget {
        .ExtractLeafs
      } if
    } ifelse
  } forall
} .internalbind def

/.pdfpagelabels {
  dup type /dicttype eq {
    dup /Nums knownoget {
      exch pop
      mark exch
      0 1 2 index length 1 sub {
        1 index exch oget
        exch
      } for
      pop
      counttomark array astore
      1 dict dup begin exch /Nums exch def end
      .pdfcvs
      mark /pdfpagelabels 3 -1 roll .pdfputparams
      dup type /booleantype ne {
        /pdfpagelabels .pdfparamerror
      } if cleartomark
    }{
      /Kids knownoget {
        dup .CountLeafs dup 1000 ge {
          (PageLabel tree too complex, ignoring PageLabels\n) print flush
          pop pop
        }{
          dict exch .ExtractLeafs mark exch dup length 0 1 3 -1 roll {
            dup 20 string cvs cvn  %% mark dict index name
            2 index exch .knownget{
                                   %% mark ... dict index object
            3 -1 roll              %% mark ... index object dict
            }{
              pop
            }ifelse
          } for
          pop
          counttomark array astore
          1 dict dup begin exch /Nums exch def end
          .pdfcvs
          mark /pdfpagelabels 3 -1 roll .pdfputparams
          dup type /booleantype ne {
            /pdfpagelabels .pdfparamerror
          } if cleartomark
        }ifelse
      }{
         (Invalid number tree in PageLabels, ignoring PageLabels\n) print flush
      }ifelse
    }ifelse
  }{
    /pdfpagelabels .pdfparamerror
  } ifelse
} .internalbind def

/pdfmark {		% -mark- <key> <value> ... <markname> pdfmark -
  counttomark 0 eq {
    /pdfmark cvx /stackunderflow signalerror
  } if
  dup type /nametype eq not {
    /pdfmark cvx /typecheck signalerror
  } if
  dup /SP eq {
    % A hack for synchronizing the clipping path.
    gsave
    [1 0 0 1 0 0] setmatrix 0 setlinewidth
    newpath -3 -3 moveto closepath stroke % Paints outside the device bbox.
    grestore
  } if
  dup /PS eq systemdict /PDFX .knownget not { //false } if
             systemdict /PDFA .knownget not { //false }{0 eq {//false}{//true} ifelse} ifelse or and {
    % Execute it since PDF/X doesn't allow to embed it.
    pop
    { dup mark eq {
        pop exit
      } if
      1 index /DataSource eq {
        exch pop
        cvx exec
      } {
        pop pop
      } ifelse
    } loop
  } {
    counttomark 1 add copy
    //.pdfmarkparams 1 index .knownget { exec } { .pdfcvsall } ifelse
    mark /pdfmark 3 -1 roll .pdfputparams
    dup type /booleantype ne {
      /pdfmark .pdfparamerror
    } if cleartomark
  } ifelse
} odef
userdict /pdfmark .undef
currentdict /.pdfmarkparams .undef

%	<dict> .hook_DSC_Creator -
/.pdf_hook_DSC_Creator
{
  % If the Creator is PScript5.dll, disable the 32 /FontType resource for
  % handling GlyphNames2Unicode. Since /FontType category can't redefine,
  % we can do only with redefining the operator 'resourcestatus'.
  systemdict  /.pdf_hooked_DSC_Creator .knownget
  {
    {//false}{//true} ifelse
  }
  {
    //true
  } ifelse

  {
    /WantsToUnicode /GetDeviceParam .special_op {
      exch pop
    }{
      //true
    }ifelse
    {
      /Creator .knownget {
        (PScript5.dll) search {
          pop pop
          systemdict /resourcestatus dup
          { dup /FontType eq 2 index 32 eq and {
              pop pop //false
            } {
              resourcestatus
            } ifelse
          } .internalbind .makeoperator .forceput
          systemdict /.pdf_hooked_DSC_Creator //true .forceput
        } executeonly if
        pop
      } executeonly if
    } {
      pop
    } ifelse
  } executeonly
  {
    pop
  } ifelse
} .forcebind odef % must be bound and hidden for .forceput

% Use the DSC processing hook to pass DSC comments to the driver.
% We use a pseudo-parameter named DSC whose value is an array:
%	/key1 (value1) ... /type
/.pdfdsc_dict 2 dict def
/.pdfdsc {	% <file> <DSC string> <dsc dict> [<prev proc>] .pdfdsc -
  0 get dup //null ne { 4 copy exch pop exec pop } { pop } ifelse 3 -1 roll pop
                % Stack: <dsc string> <dsc dict>
  20 .localvmdict 1 index { 3 copy put pop pop } forall
  3 -1 roll .parse_dsc_comments	% <dsc dict> <dict> <type>
  1 index //.pdf_hook_DSC_Creator exec
  dup /NOP ne 2 index length 1 gt or {	% Skip unparsed comments
    PDFWRDEBUG { (**** DSC comment: ) print dup //== exec 1 index === flush } if
    exch mark 4 1 roll {
                % mark <key1> <value1> ... <dsc dict> <type> <key> <value>
      3 index 2 index known {	% Skip the DSC_struct entry
        pop pop
      } {
        .pdfcvs 4 -2 roll
      } ifelse
    } forall exch pop counttomark .localvmarray astore
    mark /DSC 3 -1 roll .pdfputparams
    dup type /booleantype ne {
      /DSC .pdfparamerror
    } {
      cleartomark
    } ifelse
  } {
    pop pop pop
  } ifelse
} .internalbind def
currentdict /.pdf_hook_DSC_Creator undef
/.initialize_dsc_parser where {
  pop
  3000 % priority
  {
    % When running gpdl, due to the way gpdl has to do job encapsulation
    % the scheduled initialisation procedures get run at the start of each
    % job. Because this patches the existing procedure, it could end up
    % patching itself, so the procedure got larger/deeper with each job.
    % Eventually, copying the user params (see /.setuserparams2 in gs_lev2.ps)
    % would end up overflowing the exec stack.
    % So, as part of the patching, we push and pop a sacrificial name object
    % at the start of the executable array and before patching, we check that
    % first element, and if it is that name, we skip the patching
    currentuserparams /ProcessDSCComment .knownget
    {
      dup type /arraytype eq
      {
         0 get /.pdf_hook_DSC_Creator eq
         { //false } { //true } ifelse
      } { //true } ifelse
    } { //true } ifelse

    {
      currentglobal //true setglobal
      2 dict dup .initialize_dsc_parser readonly
      currentuserparams /ProcessDSCComment get
      1 array astore      % in case the value is executable
      /.pdf_hook_DSC_Creator /pop load 4 2 roll //.pdfdsc /exec load 6 array astore cvx readonly
      << /ProcessDSCComment 3 -1 roll >> setuserparams
      setglobal
    } if
  } .internalbind .schedule_init
} if

% ---------------- {set,current}distillerparams ---------------- %

% Define setdistillerparams / currentdistillerparams.
% Distiller parameters are currently treated as device parameters.
/.distillerparamkeys mark
                % General parameters -- all distillers
  /ASCII85EncodePages { }
  /AutoRotatePages { }
  /Binding { }
  /CompressPages { }
  /DefaultRenderingIntent { }
  /DetectBlends { }
  /DoThumbnails { }
  /ImageMemory { }
  /LockDistillerParams { }
  /LZWEncodePages { }
  /OPM { }
  /PreserveHalftoneInfo { }
  /PreserveOPIComments { }
  /PreserveOverprintSettings { }
  /TransferFunctionInfo { }
  /UCRandBGInfo { }
  /UseFlateCompression { }
                % General parameters -- PDF writer
                % StartPage and EndPage are renamed because EndPage
                % clashes with a page device parameter.
  /CoreDistVersion { }
  /CompatibilityLevel { }
                % ****** NOTE: StartPage and EndPage are disabled because
                % ****** EndPage clashes with a page device parameter.
%  /EndPage { exch pop /PDFEndPage exch }
    /PDFEndPage { pop pop }
%  /StartPage { exch pop /PDFStartPage exch }
    /PDFStartPage { pop pop }
  /Optimize { }
  /ParseDSCCommentsForDocInfo { }
  /ParseDSCComments { }
  /EmitDSCWarnings { }
  /CreateJobTicket { }
  /PreserveEPSInfo { }
  /AutoPositionEPSFiles { }
  /PreserveCopyPage { }
  /UsePrologue { }
  /OffOptimizations { }
                % PDF/X parameters
  /PDFXTrimBoxToMediaBoxOffset { }
  /PDFXSetBleedBoxToMediaBox { }
  /PDFXBleedBoxToTrimBoxOffset { }
                % Color sampled image parameters
  /ColorACSImageDict { }
  /AntiAliasColorImages { }
  /AutoFilterColorImages { }
  /ColorImageDepth { }
  /ColorImageDict { }
  /DownsampleColorImages { }
  /ColorImageDownsampleThreshold { }
  /ColorImageDownsampleType { }
  /ColorImageAutoFilterStrategy { }
  /EncodeColorImages { }
  /ColorImageFilter { }
  /ColorImageResolution { }
                % Color processing parameters
  /CalCMYKProfile { }
  /CalGrayProfile { }
  /CalRGBProfile { }
  /sRGBProfile { }
  /ColorConversionStrategy { }
  /ConvertCMYKImagesToRGB { }
  /ConvertImagesToIndexed { }
                % Grayscale sampled image parameters
  /GrayACSImageDict { }
  /AntiAliasGrayImages { }
  /AutoFilterGrayImages { }
  /GrayImageDepth { }
  /GrayImageDict { }
  /DownsampleGrayImages { }
  /GrayImageDownsampleThreshold { }
  /GrayImageDownsampleType { }
  /GrayImageAutoFilterStrategy { }
  /EncodeGrayImages { }
  /GrayImageFilter { }
  /GrayImageResolution { }
                % Monochrome sampled image parameters
  /AntiAliasMonoImages { }
  /MonoImageDepth { }
  /MonoImageDict { }
  /DownsampleMonoImages { }
  /MonoImageDownsampleThreshold { }
  /MonoImageDownsampleType { }
  /EncodeMonoImages { }
  /MonoImageFilter { }
  /MonoImageResolution { }
                % Font embedding parameters
  /AlwaysEmbed
   { dup length 0 gt
      { dup 0 get type /booleantype eq } { //false } ifelse
      { dup 0 get
         { dup length 1 sub 1 exch getinterval
         }
         { dup length 1 sub 1 exch getinterval exch pop /~AlwaysEmbed exch
         } ifelse
       }
      { exch pop /.AlwaysEmbed exch
      } ifelse
   }
  /NeverEmbed
  { dup length 0 gt
     { dup 0 get type /booleantype eq } { //false } ifelse
     { dup 0 get
        { dup length 1 sub 1 exch getinterval
        }
        { dup length 1 sub 1 exch getinterval exch pop /~NeverEmbed exch
        } ifelse
     }
     { exch pop /.NeverEmbed exch
     } ifelse
   }
  /CannotEmbedFontPolicy { }
  /EmbedAllFonts { }
  /MaxSubsetPct { }
  /SubsetFonts { }
  /DSCEncodingToUnicode { }
  /PassThroughJPEGImages { }
  /PassThroughJPXImages { }
  /PSDocOptions { }
  /PSPageOptions { }
  /PSPageOptionsWrap { }
  /AlwaysOutline { }
  /NeverOutline { }
.dicttomark readonly def
/.distillerdevice
 {
    % Check to see if the current device is a Distiller
    % and return it if so.
    /IsDistiller /GetDeviceParam .special_op {
      exch pop
    }{
      //false
    }ifelse
    { currentdevice }
    { /pdfwrite finddevice }
   ifelse
 } .internalbind def

% Some badly designed PostScript files only expect the current/set
% distillerparams operators to exist in a distiller. Since we have
% this as a runtime option, we enable these operators IFF the
% currentdevice is pdfwrite. Also, we mask their existence in
% systemdict so that 'where' and 'known' don't show them unless
% the currentdevice is pdfwrite.
/.setdistillerparams {		% <dict> setdistillerparams -
  .distillerdevice //null //false mark 4 index {
    //.distillerparamkeys 2 index .knownget { exec } { pop pop } ifelse
  } forall .putdeviceparamsonly
  dup type /booleantype ne {
    /setdistillerparams .pdfparamerror
  } {
    pop pop pop
  } ifelse
} odef
/.currentdistillerparams {	% - currentdistillerparams <dict>
  .distillerdevice //.distillerparamkeys .getdeviceparams .dicttomark
                % Patch StartPage and EndPage
                % ****** NOTE: StartPage and EndPage are disabled because
                % ****** EndPage clashes with a page device parameter.
%  begin /StartPage PDFStartPage /EndPage PDFEndPage
%  currentdict dup /PDFStartPage undef /PDFEndPage undef
%  def def currentdict end
} odef
/setdistillerparams {
  % Check to see if the current device is a Distiller
  /IsDistiller /GetDeviceParam .special_op {
    exch pop not
  }{
    //true
  }ifelse
  {
    /setdistillerparams cvx /undefined signalerror
  } if
  .setdistillerparams
} .internalbind odef
/currentdistillerparams {
  % Check to see if the current device is a Distiller
  /IsDistiller /GetDeviceParam .special_op {
    exch pop not
  }{
    //true
  }ifelse
  {
    /currentdistillerparams cvx /undefined signalerror
  } if
  .currentdistillerparams
} .internalbind odef

% Patch 'where' so that the distiller operators are only visible
% if the pdfwrite device is the current one.
{
  % Check to see if the current device is a Distiller
  /IsDistiller /GetDeviceParam .special_op {
    exch pop
  }{
    //false
  }ifelse
  {
    .where
  } {
    .where pop dup //systemdict eq { pop //false } { //true } ifelse
  } ifelse
} .internalbind
{ /currentdistillerparams /setdistillerparams /pdfmark }
{ .wheredict exch 2 index put } forall pop

% Patch 'known' to hide the systemdict version of distiller operators
% unless the currentdevice is pdfwrite.
/known {
  /currentdistillerparams 1 index eq /setdistillerparams 2 index eq or
  /pdfmark 2 index eq or {
    systemdict 2 index eq {	% only mask the operator in systemdict
      known
      % Check to see if the current device is a Distiller
      /IsDistiller /GetDeviceParam .special_op {
        exch pop not
      }{
        //true
      }ifelse
      { pop //false } if
    } {
      known
    } ifelse
  } {
    known
  } ifelse
} .forcebind odef

% Create a table for translation DSC comments into Unicode UTF-16
/.make_DSC_translation_table {        % <encoding> .make_DSC_translation_table <array>
  dup type /stringtype eq {
    cvn
  } if
  dup type /nametype eq {
    /Encoding findresource
  } if
  dup length array exch                   % [out] [in]
  0 1 2 index length 1 sub {              % [out] [in] i
    dup 2 index exch get                       % [out] [in] i n
    dup dup //null eq exch /.notdef eq or {
      pop -1
    } {
      dup //AdobeGlyphList exch .knownget {  % [out] [in] i n c
      dup type dup /arraytype eq exch /packedarraytype eq or {
        0 get % fixme: using the 1st char
      } if
      exch pop                               % [out] [in] i c
      } {                                    % [out] [in] i n
        (DSCEncoding defines a character that is not in AdobeGlyphList : )
        exch .namestring concatstrings =
        /.make_DSC_translation_table cvx /undefined signalerror
      } ifelse
    } ifelse
    3 index                                  % [out] [in] i c [out]
    3 1 roll put                             % [out] [in]
  } for
  pop                                        % [out]
} .internalbind def

1000 % priority
{
  % Note, this may not work if the initial device is not pdfwrite
  % and may require the use of -dProvideUnicode on the command line.
  % Check to see if the current device wants ToUnicode info
  /WantsToUnicode /GetDeviceParam .special_op {
    exch pop
  }{
    //false
  }ifelse
  systemdict /ProvideUnicode .knownget not { //false } if or
  {
    currentglobal //true setglobal
    /Unicode /Decoding resourcestatus {
      pop pop
      /Unicode /Decoding findresource
      .setupUnicodeDecoder
    } {
      QUIET not {
        (WARNING: /Unicode /Decoding resource is not accessible but it is useful for generating ToUnicode CMap.) =
      } if
    } ifelse
    setglobal
  } if
} .internalbind .schedule_init

1010 % priority
{
    % Set a predefined configuration in the distiller device (pdfwrite)
    /PDFSETTINGS where {
      pop /PDFSETTINGS load
    } {
      % We use the presence of the OPDFRead key as a proxy for a pdfwrite-family device
      /ForOPDFRead /GetDeviceParam .special_op {
        % Get rid of the OPDFRead key
        exch pop
        % and then check the value to see if its pdfwrite or ps2write
        { /PSL2Printer } { /default } ifelse
      } {
        /default
      } ifelse
    } ifelse
    .distillersettings exch get
    % Don't override parameters defined on the command line.
    dup length .distillercommon length add dict begin
    .distillercommon 2 {
      {
        systemdict 2 index known { pop pop } { def } ifelse
      } forall
    } repeat
    % We use the presence of the OPDFRead key as a proxy for a pdfwrite-family device
    /ForOPDFRead /GetDeviceParam .special_op {
      % Get rid of the OPDFRead key
      exch pop
      % Then check to see if OPDFRead is true or not
      not {
        systemdict /PDFX known systemdict /PDFA known or {
        /DSCEncoding where {
            /DSCEncoding get .make_DSC_translation_table
            /DSCEncodingToUnicode exch def
          } if
        } if
      } if
    } if
    currentdict end .setdistillerparams
    .distillerdevice //null //false mark .putdeviceparams
    dup type /booleantype eq not { cleartomark pop } if pop pop
} .internalbind .schedule_init

2000 % priority
{ % Note, this may not work if the initial device is not pdfwrite
  % We use the presence of the OPDFRead key as a proxy for a pdfwrite-family device
  /ForOPDFRead /GetDeviceParam .special_op {
    % Get rid of the OPDFRead key and value
    pop pop
    % Inform the device with initial graphic state. See gdev_pdf_fill_path.
    newpath fill
  } if
} .internalbind .schedule_init

.setlanguagelevel

%END PDFWR
