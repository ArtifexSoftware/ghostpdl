<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
<link rel="shortcut icon" type="image/png" href="../../images/favicon.png">
<title>The Ghostscript Interpreter Application Programming Interface (API)</title>
    <!-- Supercedes the API in DLL.htm -->
<link href="style.css" rel="stylesheet" type="text/css">
<link href="gs-style.css" rel="stylesheet" type="text/css">
</head>

<body>

    <div class="header">
    <div class="row">
    <div class="col-lt-6 logo"><a href="https://www.ghostscript.com/"><img src="images/ghostscript_logo.png" width="108" height="119" alt=""></a></div>
        <div class="col-6"><div class="row"><div class="artifexlogo"><a href="https://artifex.com" target="_blank"><img src="images/Artifex_logo.png" width="194" height="40" alt=""></a></div>
        <div class="col-12"><div class="button button1"><a href="https://artifex.com/contact-us/" title="Contact Us" target="_blank">Contact Us</a></div>
        <div class="button button2 hidden-xs"><a href="https://www.ghostscript.com/download.html" title="Download">Download</a></div></div></div>
    </div>
    </div>
    </div>

    <div class="banner">
    <div class="row">
        <div class="col-12">The Ghostscript Interpreter Application Programming Interface (API)</div>
    </div>
    </div>

    <div class="main">
    <div class="row">
    <div id="sidebar">
    <div class="sidebar-item"></div>
    <div class="col-2 leftnav">
<ul>
            <li><a href="https://www.ghostscript.com/">Home</a></li>
            <li><a href="https://www.ghostscript.com/license.html">Licensing</a></li>
            <li><a href="https://www.ghostscript.com/releases.html">Releases</a></li>
            <li><a href="https://www.ghostscript.com/documentation.html" title="Documentation">Documentation</a></li>
            <li><a href="https://www.ghostscript.com/download.html" title="Download">Download</a></li>
            <li><a href="https://www.ghostscript.com/performance.html" title="Performance">Performance</a></li>
            <li><a href="http://jbig2dec.com/" title="jbig2dec">jbig2dec</a></li>
            <li><a href="http://git.ghostscript.com/?p=ghostpdl.git;a=summary">Source</a></li>
            <li><a href="http://bugs.ghostscript.com/">Bugs</a></li>
            <li><a href="https://www.ghostscript.com/faq.html" title="FAQ">FAQ</a></li>
        </ul>
    </div>
    </div>
    <div class="col-10 page">

<!--START EDITING HERE-->

<h2>Table of contents</h2>

<ul>
<li><a href="#API">What is the Ghostscript Interpreter API?</a></li>
<li><a href="#Exported_functions ">Exported functions</a></li>

<ul>
<li><a href="#revision"><code>gsapi_revision</code></a></li>
<li><a href="#new_instance"><code>gsapi_new_instance</code></a></li>
<li><a href="#delete_instance"><code>gsapi_delete_instance</code></a></li>
<li><a href="#set_stdio_with_handle"><code>gsapi_set_stdio_with_handle</code></a></li>
<li><a href="#set_stdio"><code>gsapi_set_stdio</code></a></li>
<li><a href="#set_poll_with_handle"><code>gsapi_set_poll_with_handle</code></a></li>
<li><a href="#set_poll"><code>gsapi_set_poll</code></a></li>
<li><a href="#set_display_callback"><code>gsapi_set_display_callback</code></a></li>
<li><a href="#register_callout"><code>gsapi_register_callout</code></a></li>
<li><a href="#deregister_callout"><code>gsapi_deregister_callout</code></a></li>
<li><a href="#set_arg_encoding"><code>gsapi_set_arg_encoding</code></a></li>
<li><a href="#get_default_device_list"><code>gsapi_get_default_device_list</code></a></li>
<li><a href="#set_default_device_list"><code>gsapi_set_default_device_list</code></a></li>
<li><a href="#run"><code>gsapi_run_string_begin</code></a></li>
<li><a href="#run"><code>gsapi_run_string_continue</code></a></li>
<li><a href="#run"><code>gsapi_run_string_end</code></a></li>
<li><a href="#run"><code>gsapi_run_string_with_length</code></a></li>
<li><a href="#run"><code>gsapi_run_string</code></a></li>
<li><a href="#run"><code>gsapi_run_file</code></a></li>
<li><a href="#init"><code>gsapi_init_with_args</code></a></li>
<li><a href="#exit"><code>gsapi_exit</code></a></li>
<li><a href="#set_param"><code>gsapi_set_param</code></a></li>
<li><a href="#get_param"><code>gsapi_get_param</code></a></li>
<li><a href="#enumerate_params"><code>gsapi_enumerate_params</code></a></li>
<li><a href="#add_control_path"><code>gsapi_add_control_path</code></a></li>
<li><a href="#remove_control_path"><code>gsapi_remove_control_path</code></a></li>
<li><a href="#purge_control_paths"><code>gsapi_purge_control_paths</code></a></li>
<li><a href="#activate_path_control"><code>gsapi_activate_path_control</code></a></li>
<li><a href="#is_path_control_active"><code>gsapi_is_path_control_active</code></a></li>
<li><a href="#add_fs"><code>gsapi_add_fs</code></a></li>
<li><a href="#remove_fs"><code>gsapi_remove_fs</code></a></li>
<li><a href="#return_codes">Return codes</a></li>
<li><a href="#gsapi_fs_t">gsapi_fs_t</a></li>
<li><a href="#callout">Callouts</a></li>
</ul>
<li><a href="#Example_usage">Example usage</a></li>
<li><a href="#stdio">Standard input and output</a></li>
<li><a href="#display">Display device</a></li>
</ul>

<!-- [1.2 end table of contents] =========================================== -->

<!-- [1.3 begin hint] ====================================================== -->

<p>For other information, see the <a href="Readme.htm">Ghostscript overview</a>.</p>

<p>
<b>WARNING:</b> The API described in this document is subject to changes in
future releases, possibly ones that are not backward compatible with what
is described here.</p>

<!-- [1.3 end hint] ======================================================== -->

<hr>

<!-- [1.0 end visible header] ============================================== -->

<!-- [2.0 begin contents] ================================================== -->


<h2><a name="API"></a>What is the Ghostscript Interpreter API?</h2>

<p>
The Ghostscript interpreter can be built as a dynamic link library
(DLL) on Microsoft Windows, as a shared object on the
Linux, Unix and MacOS X platforms. With some changes, it could be built
as a static library. This document describes the Application Programming
Interface (API) for the Ghostscript interpreter library.
This should not be confused with the
<a href="Lib.htm">Ghostscript library</a> which provides a graphics
library but not the interpreter.</p>
<p>
This supercedes the old <a href="DLL.htm">DLL</a> interface.</p>
<p>
To provide the interface described in the
<a href="Use.htm">usage documentation</a>, a smaller independent
executable loads the DLL/shared object.
This executable must provide all the interaction with the windowing system,
including image windows and, if necessary, a text window.</p>

<p>
The Ghostscript interpreter library's name and characteristics differ
for each platform:</p>

<ul>
<li>The Win32 DLL <code>gsdll32.dll</code>
can be used by multiple programs simultaneously, but only once
within each process.</li>

<li>The OS/2 DLL <code>gsdll2.dll</code> has
MULTIPLE NONSHARED data segments and can be called by multiple programs
simultaneously.</li>

<li>The Linux shared object <code>libgs.so</code>
can be used by multiple programs simultaneously.</li>
        </ul>
<p>
The source for the executable is in <code>dw</code>*.* (Windows),
<code>dp</code>*.* (OS/2) and  <code>dx</code>*.* (Linux/Unix).
See these source files for examples of how to use the DLL.</p>

<p>
The source file <tt>dxmainc.c</tt> can also serve as an example of how to use the
shared library component on MacOS X, providing the same command-line tool it does
on any linux, bsd or similar operating system.</p>
<p>
At this stage, Ghostscript does not support multiple instances
of the interpreter within a single process.</p>

<hr>

<h2><a name="Exported_functions"></a>Exported functions</h2>

<p>
The functions exported by the DLL/shared object are described
in the header file <a href="../psi/iapi.h"><code>iapi.h</code></a>
and are summarised below.  Omitted from the summary are
the calling convention (e.g. __stdcall), details of return
values and error handling.</p>


<ul>
<li><code>
int
<a href="#revision">gsapi_revision</a>
(gsapi_revision_t *pr, int len);
</code></li>

<li><code>
int
<a href="#new_instance">gsapi_new_instance</a>
(void **pinstance, void *caller_handle);
</code></li>

<li><code>
void
<a href="#delete_instance">gsapi_delete_instance</a>
(void *instance);
</code></li>

<li><code>
int
<a href="#set_stdio_with_handle">gsapi_set_stdio_with_handle</a>
(void *instance,
    int(*stdin_fn)(void *caller_handle, char *buf, int len),
    int(*stdout_fn)(void *caller_handle, const char *str, int len),
    int(*stderr_fn)(void *caller_handle, const char *str, int len),
    void *caller_handle);
</code></li>

<li><code>
int
<a href="#set_stdio">gsapi_set_stdio</a>
(void *instance,
    int(*stdin_fn)(void *caller_handle, char *buf, int len),
    int(*stdout_fn)(void *caller_handle, const char *str, int len),
    int(*stderr_fn)(void *caller_handle, const char *str, int len));
</code></li>

<li><code>
int
<a href="#set_poll_with_handle">gsapi_set_poll_with_handle</a>
(void *instance, int(*poll_fn)(void *caller_handle), void *caller_handle);
</code></li>

<li><code>
int
<a href="#set_poll">gsapi_set_poll</a>
(void *instance, int(*poll_fn)(void *caller_handle));
</code></li>

<li><code>
int
<a href="#set_display_callback">gsapi_set_display_callback</a>
(void *instance, display_callback *callback);
</code></li>

<li><code>
int
<a href="#register_callout">gsapi_register_callout</a>
(void *instance, gs_callout callout, void *callout_handle);
</code></li>

<li><code>
void
<a href="#deregister_callout">gsapi_deregister_callout</a>
(void *instance, gs_callout callout, void *callout_handle);
</code></li>

<li><code>
int
<a href="#set_arg_encoding">gsapi_set_arg_encoding</a>
(void *instance, int encoding);
</code></li>

<li><code>
int
<a href="#get_default_device_list">gsapi_get_default_device_list</a>(void *instance, char **list, int *listlen);
</code></li>

<li><code>
int
<a href="#set_default_device_list">gsapi_set_default_device_list</a>(void *instance, const char *list, int listlen);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_string_begin</a>
(void *instance, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_string_continue</a>
(void *instance,
    const char *str, unsigned int length, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_string_end</a>
(void *instance, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_string_with_length</a>
(void *instance,
    const char *str, unsigned int length, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_string</a>
(void *instance,
    const char *str, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#run">gsapi_run_file</a>
(void *instance,
    const char *file_name, int user_errors, int *pexit_code);
</code></li>

<li><code>
int
<a href="#init">gsapi_init_with_args</a>
(void *instance, int argc, char **argv);
</code></li>

<li><code>
int
<a href="#exit">gsapi_exit</a>
(void *instance);
</code></li>

<li><code>
int
<a href="#set_param">gsapi_set_param</a>(void *instance, const char *param, const void *value, gs_set_param_type type);
</code></li>

<li><code>
    int
    <a href="#get_param">gsapi_get_param</a>(void *instance, const char *param, void *value, gs_set_param_type type);
</code></li>

<li><code>
int
<a href="#enumerate_params">gsapi_enumerate_params</a>(void *instance, void **iter, const char **key, gs_set_param_type *type);
</code></li>

<li><code>
int
<a href="#add_control_path">gsapi_add_control_path</a>(void *instance, int type, const char *path);
</code></li>

<li><code>
int
<a href="#remove_control_path">gsapi_remove_control_path</a>(void *instance, int type, const char *path);
</code></li>

<li><code>
void
<a href="#purge_control_paths">gsapi_purge_control_paths</a>(void *instance, int type);
</code></li>

<li><code>
void
<a href="#activate_path_control">gsapi_activate_path_control</a>(void *instance, int enable);
</code></li>

<li><code>
int
<a href="#is_path_control_active">gsapi_is_path_control_active</a>(void *instance);
</code></li>

<li><code>
int
<a href="#add_fs">gsapi_add_fs</a>
(void *instance,
    gsapi_fs_t *fs, void *secret);
</code></li>

<li><code>
void
<a href="#remove_fs">gsapi_remove_fs</a>
(void *instance,
    gsapi_fs_t *fs, void *secret);
</code></li>

</ul>

<h3><a name="revision"></a><code>gsapi_revision()</code></h3>

<blockquote>
This function returns the revision numbers and strings of the Ghostscript
interpreter library; you should call it before any other interpreter
library functions to make sure that the correct version of the
Ghostscript interpreter has been loaded.

<blockquote>
<pre>
typedef struct gsapi_revision_s {
    const char *product;
    const char *copyright;
    long revision;
    long revisiondate;
} gsapi_revision_t;
gsapi_revision_t r;

if (gsapi_revision(&amp;r, sizeof(r)) == 0) {
    if (r.revision &lt; 650)
       printf("Need at least Ghostscript 6.50");
}
else {
    printf("revision structure size is incorrect");
}
</pre></blockquote>
</blockquote>


<h3><a name="new_instance"></a><code>gsapi_new_instance()</code></h3>
<blockquote>
Create a new instance of Ghostscript.
This instance is passed to most other gsapi functions.
The caller_handle is the default value that will be provided to callback functions.

<b>Unless Ghostscript has been compiled with the </code>GS_THREADSAFE</code>
define, only one instance at a time is supported.</b>

<p>Historically, Ghostscript has only supported a single instance; any
attempt to create more than one at a time would result in gsapi_new_instance
returning an error. Experimental work has been done to lift this
restriction; if Ghostscript is compiled with the GS_THREADSAFE define
then multiple concurrent instances are permitted.</p>

<p>While the core Ghostscript devices are believed to be thread safe
now, certain devices are known not to be (particularly the contrib
devices). The makefiles currently make no attempt to exclude these
from builds. If you enable GS_THREADSAFE then you should check to ensure
that you do not rely on such devices (check for global variable use).</p>
<p>
The first parameter, is a pointer to an opaque pointer (&quot;<code>void **</code>&quot;).
The opaque pointer (&quot;<code>void *</code>&quot;) must be initialised to <code>NULL</code> before
the call to <code>gsapi_new_instance()</code>. See <a href="#Example_1">Example 1</a>.
</blockquote>


<h3><a name="delete_instance"></a><code>gsapi_delete_instance()</code></h3>
<blockquote>
Destroy an instance of Ghostscript.
Before you call this, Ghostscript must have finished.
If Ghostscript has been initialised, you must call
<code>gsapi_exit</code> before <code>gsapi_delete_instance</code>.
</blockquote>


<h3><a name="set_stdio_with_handle"></a><code>gsapi_set_stdio_with_handle()</code></h3>
<blockquote>
<p>Set the callback functions for stdio, together with the
handle to use in the callback functions.
The stdin callback function should return the number of
characters read, 0 for EOF, or -1 for error.
The stdout and stderr callback functions should return
the number of characters written.
<p><b>NOTE:</b> These callbacks do not affect output device I/O when
using &quot;<code>%stdout</code>&quot; as the output file. In that
case, device output will still be directed to the process &quot;stdout&quot;
file descriptor, not to the stdio callback.
</blockquote>

<h3><a name="set_stdio"></a><code>gsapi_set_stdio()</code></h3>
<blockquote>
<p>Set the callback functions for stdio.  The handle used
in the callbacks will be taken from the value passed
to <code><a href="#new_instance">gsapi_new_instance</a></code>.  Otherwise the behaviour of this
function matches <code><a href="#set_stdio_with_handle">gsapi_set_stdio_with_handle</a></code>.
</blockquote>


<h3><a name="set_poll_with_handle"></a><code>gsapi_set_poll_with_handle()</code></h3>
<blockquote>
Set the callback function for polling, together with the handle to pass
to the callback function. This function will only be called if
the Ghostscript interpreter was compiled with <code>CHECK_INTERRUPTS</code>
as described in <code><a href="../base/gpcheck.h">gpcheck.h</a></code>.
<p>
The polling function should return zero if all is well, and return
negative if it wants ghostscript to abort. This is often
used for checking for a user cancel. This can also be used for
handling window events or cooperative multitasking.</p>
<p>
The polling function is called very frequently during interpretation and
rendering so it must be fast. If the function is slow, then using a counter
to return 0 immediately some number of times can be used to reduce the
performance impact.</p>
</blockquote>

<h3><a name="set_poll"></a><code>gsapi_set_poll()</code></h3>
<blockquote>
Set the callback function for polling.  The handle passed to the
callback function will be taken from the handle passed to
<code><a href="#new_instance">gsapi_new_instance</a></code>.
Otherwise the behaviour of this function matches
<code><a href="#set_poll_with_handle">gsapi_set_poll_with_handle</a></code>.
</blockquote>

<h3><a name="set_display_callback"></a><code>gsapi_set_display_callback()</code></h3>
<blockquote>
<b>This call is deprecated; please use
<code><a href="#register_callout">gsapi_register_callout</a></code>
to register a <a href="#callout">callout</a> handler for the
<a href="#display">display</a> device in preference.</b>
Set the callback structure for the <a href="#display">display</a>
device. The handle passed in the callback functions is taken from
the <code>DisplayHandle</code> parameter (or NULL if there is no
such parameter). If the <a href="#display">display</a> device is used,
this must be called after
<code>gsapi_new_instance()</code>
and before <code>gsapi_init_with_args()</code>.
See <code><a href="../devices/gdevdsp.h">gdevdsp.h</a></code>
for more details.
</blockquote>

<h3><a name="register_callout"></a><code>gsapi_register_callout()</code></h3>
<blockquote>
<p>This call registers a <code><a href="#callout">callout</a></code>
handler.</p>
</blockquote>

<h3><a name="deregister_callout"></a><code>gsapi_deregister_callout()</code></h3>
<blockquote>
<p>This call deregisters a <code><a href="#callout">callout</a></code> handler
previously registered with <code><a href="#register_callout">gsapi_register_callout</a></code>.
All three arguments must match exactly for the callout handler to
be deregistered.</p>
</blockquote>

<h3><a name="set_arg_encoding"></a><code>gsapi_set_arg_encoding()</code></h3>
<blockquote>
Set the encoding used for the interpretation of all subsequent args
supplied via the gsapi interface on this instance. By default we
expect args to be in encoding 0 (the 'local' encoding for this OS).
On Windows this means "the currently selected codepage". On Linux this
typically means utf8. This means that omitting to call this function
will leave Ghostscript running exactly as it always has. Please note
that use of the 'local' encoding is now deprecated and should be
avoided in new code.
This must be called after  <code>gsapi_new_instance()</code>
and before <code>gsapi_init_with_args()</code>.
</blockquote>

<h3><a name="set_default_device_list"></a><code>set_default_device_list()</code></h3>
<blockquote>
Set the string containing the list of default device names,
for example "display x11alpha x11 bbox". Allows the calling
application to influence which device(s) gs will try, in order,
in it's selection of the default device.
This must be called after  <code>gsapi_new_instance()</code>
and before <code>gsapi_init_with_args()</code>.
</blockquote>

<h3><a name="get_default_device_list"></a><code>get_default_device_list()</code></h3>
<blockquote>
Returns a pointer to the current default device string.
This must be called after  <code>gsapi_new_instance()</code>
and before <code>gsapi_init_with_args()</code>.
</blockquote>

<h3><a name="init"></a><code>gsapi_init_with_args()</code></h3>
<blockquote>
Initialise the interpreter.
This calls <code>gs_main_init_with_args()</code> in
<code><a href="../psi/imainarg.c">imainarg.c</a></code>.
See below for <a href="#return_codes">return codes</a>.
The arguments are the same as the "C" main function:
argv[0] is ignored and the user supplied arguments
are argv[1] to argv[argc-1].
</blockquote>

<h3><a name="run"></a><code>gsapi_run_*()</code></h3>
<blockquote>
The <code>gsapi_run_*</code> functions are like
<code>gs_main_run_*</code> except that the error_object is omitted.
If these functions return &lt;= -100, either quit or a fatal
error has occured.  You must call <code>gsapi_exit()</code> next.
The only exception is <code>gsapi_run_string_continue()</code>
which will return <code>gs_error_NeedInput</code> if all is well.
See below for <a href="#return_codes">return codes</a>.
<p>
The address passed in <code>pexit_code</code> will be used to return the
exit code for the interpreter in case of a quit or fatal error. The
<code>user_errors</code>  argument is normally set to zero to indicate that
errors should be handled through the normal mechanisms within the
interpreted code. If set to a negative value, the functions will return
an error code directly to the caller, bypassing the interpreted
language. The interpreted language's error handler is bypassed, regardless of
<code>user_errors</code> parameter, for the <code>gs_error_interrupt</code>
generated when <a href="#set_poll">the polling callback</a> returns a negative
value. A positive <code>user_errors</code> is treated the same as zero.</p>
<p>
There is a 64 KB length limit on any buffer submitted to a
<code>gsapi_run_*</code> function for processing. If you have more
than 65535 bytes of input then you must split it into smaller
pieces and submit each in a separate
<code>gsapi_run_string_continue()</code> call.</p>
</blockquote>

<h3><a name="exit"></a><code>gsapi_exit()</code></h3>
<blockquote>
Exit the interpreter.
This must be called on shutdown if <code>gsapi_init_with_args()</code>
has been called, and just before <code>gsapi_delete_instance()</code>.
</blockquote>

<h3><a name="set_param"></a><code>gsapi_set_param()</code></h3>
<blockquote>
Set a parameter.
Broadly, this is equivalent to setting a parameter using <code>-d</code>, <code>-s</code> or <code>-p</code> on the command line. This call cannot be made during a <code>run_string</code> operation.
<p>
Parameters in this context are not the same as 'arguments' as processed by <code>gsapi_init_with_args</code>, but often the same thing can be achieved. For example, with <code>gsapi_init_with_args</code>, we can pass &quot;<code>-r200</code>&quot; to change the resolution. Broadly the same thing can be achieved by using <code>gsapi_set_param</code> to set a parsed value of &quot;<code>&lt;&lt;/HWResolution [ 200.0 200.0 ]&gt;&gt;</code>&quot;.
<p>
Note, that internally, when we set a parameter, we perform an <code>initgraphics</code> operation. This means that using <code>set_param</code> other than at the start of a page is likely to give unexpected results.
<p>Further, note that attempting to set a parameter that the device does not recognise will be silently ignored, and that parameter will not be found in subsequent <code>gsapi_get_param</code> calls.
<p>The <code>type</code> argument dictates the kind of object that <code>value</code> points to:
<pre><code>typedef enum {
    gs_spt_invalid = -1,
    gs_spt_null    = 0,   /* void * is NULL */
    gs_spt_bool    = 1,   /* void * is a pointer to an int (0 false,
                           * non-zero true). */
    gs_spt_int     = 2,   /* void * is a pointer to an int */
    gs_spt_float   = 3,   /* void * is a float * */
    gs_spt_name    = 4,   /* void * is a char * */
    gs_spt_string  = 5,   /* void * is a char * */
    gs_spt_long    = 6,   /* void * is a long * */
    gs_spt_i64     = 7,   /* void * is an int64_t * */
    gs_spt_size_t  = 8,   /* void * is a size_t * */
    gs_spt_parsed  = 9,   /* void * is a pointer to a char * to be parsed */

    /* Setting a typed param causes it to be instantly fed to to the
     * device. This can cause the device to reinitialise itself. Hence,
     * setting a sequence of typed params can cause the device to reset
     * itself several times. Accordingly, if you OR the type with
     * gs_spt_more_to_come, the param will held ready to be passed into
     * the device, and will only actually be sent when the next typed
     * param is set without this flag (or on device init). Not valid
     * for get_typed_param. */
    gs_spt_more_to_come = 1<<31
} gs_set_param_type;
</code></pre>
<p>Combining a type value by ORRing it with the <code>gs_spt_more_to_come</code> flag will cause the <code>set_param</code> operation to be queued internally, but not actually be sent to the device. Thus a series of <code>set_param</code> operations can be queued, for example as below:
<pre>
  int code = gsapi_set_param(instance,
                             "HWResolution",
                             "[300 300]",
                             gs_spt_parsed | gs_spt_more_to_come);
  if (code >= 0) {
    int i = 1;
    code = gsapi_set_param(instance,
                           "FirstPage",
                           &i,
                           gs_spt_int | gs_spt_more_to_come);
  }
  if (code >= 0) {
    int i = 3;
    code = gsapi_set_param(instance,
                           "DownScaleFactor",
                           &i,
                           gs_spt_int);
  }
</pre>
<p>This enables a series of set operations to be performed 'atomically'. This can be useful for performance, in that any reconfigurations to the device (such as page size changes or memory reallocations) will only happen when all the parameters are sent, rather than potentially each time each one is sent.
</blockquote>

<h3><a name="get_param"></a><code>gsapi_get_param()</code></h3>
<blockquote>
Get a parameter.
Retrieve the current value of a parameter.
<p>If an error occurs, the return value is negative. Otherwise the return value is the number of bytes required for storage of the value. Call once with <code>value = NULL</code> to get the number of bytes required, then call again with <code>value</code> pointing to at least the required number of bytes where the value will be copied out. Note that the caller is required to know the type of value in order to get it. For all types other than <code>string</code>, <code>name</code>, and <code>parsed</code> knowing the type means you already know the size required.
<p>
This call retrieves parameters/values that have made it to the device. Thus, any values set using the <code>gs_spt_more_to_come</code> without a following call without that flag will not be retrieved. Similarly, attempting to get a parameter before <code>gsapi_init_with_args</code> has been called will not list any, even if <code>gsapi_set_param</code> has been used.
<p>
Attempting to read a parameter that is not set will return <code>gs_error_undefined (-21)</code>. Note that calling <code>gsapi_set_param</code> followed by <code>gsapi_get_param</code> may not find the value, if the device did not recognise the key as being one of its configuration keys.
</blockquote>

<h3><a name="enumerate_params"></a><code>gsapi_enumerate_params()</code></h3>
<blockquote>
Enumerate the current parameters.
Call repeatedly to list out the current parameters.
<p>
  The first call should have <code>*iter = NULL</code>. Subsequent calls should pass the same pointer in so the iterator can be updated. Negative return codes indicate error, 0 success, and 1 indicates that there are no more keys to read. On success, <code>key</code> will be updated to point to a null terminated string with the key name that is guaranteed to be valid until the next call to <code>gsapi_enumerate_params</code>. If <code>type</code> is non <code>NULL</code> then <code>*type</code> will be updated to have the type of the parameter.
<p>
Note that only one enumeration can happen at a time. Starting a second enumeration will reset the first.
<p>
The enumeration only returns parameters/values that have made it to the device. Thus, any values set using the <code>gs_spt_more_to_come</code> without a following call without that flag will not be retrieved. Similarly, attempting to enumerate parameters before <code>gsapi_init_with_args</code> has been called will not list any, even if <code>gsapi_set_param</code> has been used.
</blockquote>

<h3><a name="add_control_path"></a><code>gsapi_add_control_path()</code></h3>
<blockquote>
Add a (case sensitive) path to one of the lists of permitted paths for file access.
See <a href="Use.htm#Safer">here</a> for more information about permitted paths.
</blockquote>

<h3><a name="remove_control_path"></a><code>gsapi_remove_control_path()</code></h3>
<blockquote>
Remove a (case sensitive) path from one of the lists of permitted paths for file access.
See <a href="Use.htm#Safer">here</a> for more information about permitted paths.
</blockquote>

<h3><a name="purge_control_paths"></a><code>gsapi_purge_control_paths()</code></h3>
<blockquote>
Clear all the paths from one of the lists of permitted paths for file access.
See <a href="Use.htm#Safer">here</a> for more information about permitted paths.
</blockquote>

<h3><a name="activate_path_control"></a><code>gsapi_activate_path_control()</code></h3>
<blockquote>
Enable/Disable path control (i.e. whether paths are checked against permitted paths
before access is granted).
See <a href="Use.htm#Safer">here</a> for more information about permitted paths.
</blockquote>

<h3><a name="is_path_control_active"></a><code>gsapi_is_path_control_active()</code></h3>
<blockquote>
Query whether path control is activated or not.
See <a href="Use.htm#Safer">here</a> for more information about permitted paths.
</blockquote>

<h3><a name="add_fs"></a><code>gsapi_add_fs()</code></h3>
<blockquote>
Adds a new 'Filing System' to the interpreter.
This enables callers to implement their own filing systems. The system
starts with just the conventional 'file' handlers installed, to allow
access to the local filing system. Whenever files are to be opened
from the interpreter, the file paths are offered around each registered
filing system in turn (from most recently registered to oldest), until
either an error is given, or the file is opened successfully.
<p>
Details of the <code>gsapi_fs_t</code> are given
<a href="#gsapi_fs_t">below</a>.
</blockquote>

<h3><a name="remove_fs"></a><code>gsapi_remove_fs()</code></h3>
<blockquote>
Remove a previously registered 'Filing System' from the interpreter.
Both the function pointers within the <code>gs_fs_t</code> and the
secret value must match exactly.
<p>
</blockquote>

<h3><a name="return_codes"></a>Return codes</h3>

<p>
The <code>gsapi_init_with_args</code>, <code>gsapi_run_*</code> and
<code>gsapi_exit</code> functions return an integer code.</p>

<table>
<tr>
    <th colspan="3">Return Codes from gsapi_*()</th>
</tr>
<tr>
    <th>CODE</th>
    <th colspan="2">STATUS</th>
</tr>
<tr>
    <td>0</td>
    <td colspan="2">No errors</td>
</tr>
<tr>
    <td>gs_error_Quit</td>
    <td colspan="2">"<code>quit</code>" has been executed. This is not an error. <code>gsapi_exit()</code> must be called next.</td>
</tr>
<tr>
    <td>gs_error_interrupt</td>
    <td colspan="2"><a href="#set_poll">The polling callback function</a> returned a negative value, requesting Ghostscript to abort.</td>
</tr>
<tr>
    <td>gs_error_NeedInput</td>
    <td colspan="2">More input is needed by <code>gsapi_run_string_continue()</code>. This is not an error.</td>
</tr>
<tr>
    <td>gs_error_Info</td>
    <td colspan="2">"<code>gs -h</code>" has been executed. This is not an error. <code>gsapi_exit()</code> must be called next.</td>
</tr>
<tr>
    <td>&lt; 0</td>
    <td colspan="2">Error</td>
</tr>
<tr>
    <td>&lt;= gs_error_Fatal</td>
    <td colspan="2">Fatal error. <code>gsapi_exit()</code> must be called next.</td>
</tr>
</table>

<p>
The <code>gsapi_run_*()</code> functions do not flush stdio.
If you want to see output from Ghostscript you
must do this explicitly as shown in the example below.</p>

<p>
When executing a string with <code>gsapi_run_string_*()</code>,
<code>currentfile</code> is the input from the string.
Reading from <code>%stdin</code> uses the stdin callback.</p>

<h3><a name="gsapi_fs_t"></a>gsapi_fs_t</h3>
<p>Each 'filing system' within gs is a structure of function
pointers; each function pointer gives a handler from taking a
different named resource (a file, a pipe, a printer, a scratch
file etc) and attempts to open it.

<pre>
typedef struct
{
    int (*open_file)(const gs_memory_t *mem,
                           void        *secret,
                     const char        *fname,
                     const char        *mode,
                           gp_file    **file);
    int (*open_pipe)(const gs_memory_t *mem,
                           void        *secret,
                     const char        *fname,
                           char        *rfname, /* 4096 bytes */
                     const char        *mode,
                           gp_file    **file);
    int (*open_scratch)(const gs_memory_t *mem,
                              void        *secret,
                        const char        *prefix,
                              char        *rfname, /* 4096 bytes */
                        const char        *mode,
                              int          rm,
                              gp_file    **file);
    int (*open_printer)(const gs_memory_t *mem,
                              void        *secret,
                              char        *fname, /* 4096 bytes */
                              int          binary,
                              gp_file    **file);
    int (*open_handle)(const gs_memory_t *mem,
                             void        *secret,
                             char        *fname, /* 4096 bytes */
                       const char        *mode,
                             gp_file    **file);
} gsapi_fs_t;
</pre>
<p>If the filename (always given in utf-8 format) is recognised as
being one that the filing system handles (perhaps by the prefix used),
then it should open the file, fill in the <code>gp_file</code>
pointer and return 0.
<p>If the filename is not-recognised as being one that the filing
system handles, then returning 0 will cause the filename to be
offered to other registered filing systems.
<p>If an error is returned (perhaps gs_error_invalidfileaccess),
then no other filing system will be allowed to try to open the
file. This provides a mechanism whereby a caller to gsapi can
completely control access to all files accessed via <code>gp_fopen</code>
at runtime.
<p>Note, that while most file access within ghostscript will be
redirected via these functions, stdio will not; see the existing
mechanisms within Ghostscript for intercepting/replacing this.
<ul>
<li>The <code>open_file</code> function pointer will be called when
something (most often a call to <code>gp_fopen</code>) attempts to
open a file.
<li>The <code>open_pipe</code> function pointer will be called when
something (most often a call to <code>gp_popen</code>) attempts to
open a pipe. <code>rfname</code> points to a 4K buffer in which the
actual name of the opened pipe should be returned.
<li>The <code>open_scratch</code> function pointer will be called when
something (most often a call to <code>gp_open_scratch_file</code> or
<code>gp_open_scratch_file_rm</code>) attempts to open a temporary file.
<code>rfname</code> points to a 4K buffer in which the actual name of
the opened pipe should be returned. If <code>rm</code> is true, then
the file should be set to delete itself when all handles to it are closed.
<li>The <code>open_printer</code> function pointer will be called when
something (most often a call to <code>gp_open_printer</code>) attempts
to open a stream to a printer. If <code>binary</code> is true, then
the stream should be opened as binary; most streams will be binary by
default - this has historical meaning on OS/2.
<li>The <code>open_handle</code> function pointer will be called when
something (most often a call via the postscript <code>%handle%</code>
IO device) attempts to open a Windows handle. This entry point will
never be called on non-Windows builds.
</ul>
<p>Any of these which are left as NULL will never be called; a filing
system with all of the entries left as NULL is therefore pointless.
<p>The most complex part of the implementation of these functions
is the creation of a <code>gp_file</code> instance to return. There are
some helper functions for this, best explained by example.
<p>Let us consider a hypothetical filing system that encrypts data as
it is written, and decrypts it as it is read back. As each file is
read and written the encryption/decryption routines will need to use
some state, carried between calls to the filing system. We therefore
might define a new type 'derived' from <code>gp_file</code> as follows:

<pre>
typedef struct
{
   gp_file base;
   /* State private to the implementation of this file for encryption/decryption */
   /* For example: */
   int foo;
   char *bar;
} gp_file_crypt;
</pre>

<p>An implementation of <code>gs_fs_t</code> for our 'crypt' filing system
might then look like this:

<pre>
gsapi_fs_t gs_fs_crypt =
{
    crypt_open_file,
    NULL,            /* open_pipe */
    NULL,            /* open_scratch */
    NULL,            /* open_printer */
    NULL             /* open_handle */
};
</pre>

<p>In the above definition, we define a single handler, to cope with the
opening of our input/output files. If we wanted to encrypt/decrypt
other files too (perhaps the temporary files we produce) we'd need to
define additional handlers (such as <code>open_scratch</code>).

<p>Our handler might look as follows:
<pre>
int crypt_open_file(const gs_memory_t  *mem,
                          void         *secret,
                    const char         *filename,
                    const char         *mode,
                          gp_file     **file)
{
    gp_file_crypt crypt;

    /* Ignore any filename not starting with "crypt://" */
    if (strncmp(filename, "crypt://", 8) != 0)
        return 0;

    /* Allocate us an instance (and fill in the non-crypt-specific
     * internals) */
    crypt = (gp_file_crypt *)gp_file_alloc(mem, &crypt_ops, sizeof(*crypt), "gp_file_crypt");
    if (crypt == NULL)
        return gs_error_VMerror; /* Allocation failed */

    /* Setup the crypt-specific state */
    crypt->foo = 1;
    crypt->bar = gs_alloc_bytes(mem->non_gc_memory, 256, "bar");
    /* If allocations fail, we need to clean up before exiting */
    if (crypt->bar) {
        gp_file_dealloc(crypt);
	return gs_error_VMerror;
    }

    /* Return the new instance */
    *file = &crypt.base;
    return 0;
}
</pre>

<p>The crucial part of this function is the definition of <code>crypt_ops</code>,
an instance of the <code>gp_file_ops_t</code> type; a table of function pointers
that implement the actual operations required.

<pre>
typedef struct {
    int          (*close)(gp_file *);
    int          (*getc)(gp_file *);
    int          (*putc)(gp_file *, int);
    int          (*read)(gp_file *, size_t size, unsigned int count, void *buf);
    int          (*write)(gp_file *, size_t size, unsigned int count, const void *buf);
    int          (*seek)(gp_file *, gs_offset_t offset, int whence);
    gs_offset_t  (*tell)(gp_file *);
    int          (*eof)(gp_file *);
    gp_file     *(*dup)(gp_file *, const char *mode);
    int          (*seekable)(gp_file *);
    int          (*pread)(gp_file *, size_t count, gs_offset_t offset, void *buf);
    int          (*pwrite)(gp_file *, size_t count, gs_offset_t offset, const void *buf);
    int          (*is_char_buffered)(gp_file *file);
    void         (*fflush)(gp_file *file);
    int          (*ferror)(gp_file *file);
    FILE        *(*get_file)(gp_file *file);
    void         (*clearerr)(gp_file *file);
    gp_file     *(*reopen)(gp_file *f, const char *fname, const char *mode);
} gp_file_ops_t;
</pre>

<p>These functions generally follow the same patterns as the posix functions that match them,
and so in many cases we will describe these with references to such.
Whenever these routines are called, they will be passed a <code>gp_file</code> pointer.
This pointer will have originated from the <code>crypt_open_file</code> call, and so can
safely be cast back to a <code>gp_file_crypt</code> pointer to allow private data to be accessed.

<dl>
<dt><code>close(gp_file *)</code>
<dd>close the given file; free any storage in the crypt specific parts of <code>gp_file_crypt</code>,
but not the gp_file_crypt structure itself.

<dt><code>int getc(gp_file *)</code>
<dd>Get a single character from the file, returning it as an int (or -1 for EOF).
Behaves like <code>fgetc(FILE *)</code>.

<dt><code>int putc(gp_file *, int)</code>
<dd>Put a single character to the file, returning the character on success, or
EOF (and setting the error indicator) on error.
Behaves like <code>fgetc(FILE *)</code>.

<dt><code>int read(gp_file *, size_t size, unsigned int count, void *buf)</code>
<dd>Reads count entries of size bytes the file into buf, returning the number
of entries read. Behaves like <code>fread(FILE *, size, count, buf)</code>.

<dt><code>int write(gp_file *, size_t size, unsigned int count, const void *buf)</code>
<dd>Writes count entries of size bytes from buf into the file, returning the
number of entries written. Behaves like <code>fwrite(FILE *, size, count, buf)</code>.

<dt><code>int seek(gp_file *, gs_offset_t offset, int whence)</code>
<dd>Seeks within the file. Behaves like <code>fseek(FILE *, offset, whence)</code>.

<dt><code>gs_offset_t tell(gp_file *)</code>
<dd>Returns the current offset within the file. Behaves like <code>ftell(FILE *)</code>.

<dt><code>int eof(gp_file *)</code>
<dd>Returns 1 if we are at the end of the file, 0 otherwise. Behaves like
<code>feof(FILE *)</code>.

<dt><code>gp_file * dup(gp_file *, const char *mode)</code>
<dd>Optional function, only used if clist files are to be stored in this filing system.
Behaves like <code>fdup(FILE *)</code>. Leave NULL if not implemented.

<dt><code>int seekable(gp_file *)</code>
<dd>Returns 1 if the file is seekable, 0 otherwise. Certain output devices will
only work with seekable files.

<dt><code>int pread(gp_file *, size_t count, gs_offset_t offset, void *buf)</code>
<dd>Optional function, only used if clist files are to be stored in this filing system.
Behaves like an atomic <code>fseek(FILE *, offset, 0)</code> and <code>fread(FILE *, 1, count, buf)</code>.
Akin to <code>pread</code>.

<dt><code>int pwrite(gp_file *, size_t count, gs_offset_t offset, const void *buf)</code>
<dd>Optional function, only used if clist files are to be stored in this filing system.
Behaves like an atomic <code>fseek(FILE *, offset, 0)</code> and <code>fwrite(FILE *, 1, count, buf)</code>.
Akin to <code>pwrite</code>.

<dt><code>int is_char_buffered(gp_file *file)</code>
<dd>Returns 1 if the file is character buffered, 0 otherwise. Used for handling
reading from terminals. Very unlikely to be used, so returning 0 all the time
should be safe. Leave NULL to indicate "always 0".

<dt><code>void fflush(gp_file *file)</code>
<dd>Ensures that any buffered data is written to the file. Behaves like <code>fflush(FILE *)</code>.
Leave NULL to indicate that no flushing is ever required.

<dt><code>int ferror(gp_file *file)</code>
<dd>Returns non-zero if there has been an error, or 0 otherwise. Behaves like <code>ferror(FILE *)</code>.

<dt><code>FILE * get_file(gp_file *file)</code>
<dd>Optional: Gets the FILE * pointer that backs this file. Required for a few devices
that insist on working with FILE *'s direct. Generally safe to leave this set to NULL, and those
devices will fail gracefully.

<dt><code>void clearerr(gp_file *file)</code>
<dd>Clear the error and EOF values for a file. Behaves like <code>clearerror(FILE *)</code>.

<dt><code>gp_file * reopen(gp_file *f, const char *fname, const char *mode)</code>
<dd>Optional function, only used if the <code>gp_file</code> came from an <code>open_scratch</code>
call; can be left as NULL if the <code>open_scratch</code> pointer is set to NULL.
Reopen a stream with a different mode. Behaves like
<code>freopen(fname, mode, FILE *)</code>.
</dl>

<h3><a name="callout"></a>Callouts</h3>
<blockquote>
<p>Callouts are a mechanism
for the core code (specifically devices) to communicate with the
user of gsapi. This communication can take the form of passing
information out vis-a-vis what devices are doing, or requesting
configuration from the caller to affect exactly how the device
itself works.</p>
<p>This is deliberately an extensible system, so exact details of
callouts should be documented with the device in question. In general
however a callout handler will be of the form:</p>
<pre>
typedef int (*gs_callout)(void *callout_handle,
                          const char *device_name,
                          int id,
                          int size,
                          void *data);
</pre>
<p>The <code>callout_handle</code> value passed to the callout will
be the value passed in at registration. The <code>device_name</code>
should be a null-terminated string giving the name of the device
(though care should be taken to cope with the case where
<code>device_name</code> is NULL for potential future uses).
The <code>id</code> value will have a (device-specific) meaning; see
the documentation for the device in question for more details. The
same <code>id</code> value may be used to mean different things in
different devices.
Finally, <code>size</code> and <code>data</code> have callout
specific meanings, but typically, <code>data</code> will be a pointer
to data block (which may either be uninitialised or wholly/partially
initialised on entry, and may be updated on exit), and <code>size</code>
will be the size (in bytes) of the block pointed to by <code>data</code>.
</p>
<p>A return value of -1 (<code>gs_error_unknownerror</code>) means
the callout was not recognised by the handler, and should be passed
to more handlers. Other negative values are interpreted as standard
Ghostscript error values, and stop the propagation of the callout.
Non-negative return codes mean the callout was handled and should
not be passed to any more registered callout handlers.</p>
</blockquote>

<hr>
<h2><a name="Example_usage"></a>Example Usage</h2>
<p>To try out the following examples in a development environment like Microsoft's
developer tools or Metrowerks Codewarrior, create a new project, save the example
source code as a <tt>.c</tt> file and add it, along with the Ghostscript dll or shared
library. You will also need to make sure the Ghostscript headers are available, either
by adding their location (the <tt>src</tt> directory in the Ghostscript source
distribution) to the project's search path, or by copying ierrors.h and iapi.h into the
same directory as the example source.</p>

<h3><a name="Example_1"></a>Example 1</h3>
<pre>
/* Example of using GS DLL as a ps2pdf converter.  */

#if defined(_WIN32) &amp;&amp; !defined(_Windows)
# define _Windows
#endif
#ifdef _Windows
/* add this source to a project with gsdll32.dll, or compile it directly with:
 *   cl -D_Windows -Isrc -Febin\ps2pdf.exe ps2pdf.c bin\gsdll32.lib
 */
# include &lt;windows.h&gt;
# define GSDLLEXPORT __declspec(dllimport)
#endif

#include "ierrors.h"
#include "iapi.h"

void *minst = NULL;

int main(int argc, char *argv[])
{
    int code, code1;
    const char * gsargv[7];
    int gsargc;
    gsargv[0] = "";
    gsargv[1] = "-dNOPAUSE";
    gsargv[2] = "-dBATCH";
    gsargv[3] = "-dSAFER";
    gsargv[4] = "-sDEVICE=pdfwrite";
    gsargv[5] = "-sOutputFile=out.pdf";
    gsargv[6] = "input.ps";
    gsargc=7;

    code = gsapi_new_instance(&amp;minst, NULL);
    if (code &lt; 0)
        return 1;
    code = gsapi_set_arg_encoding(minst, GS_ARG_ENCODING_UTF8);
    if (code == 0)
        code = gsapi_init_with_args(minst, gsargc, gsargv);
    code1 = gsapi_exit(minst);
    if ((code == 0) || (code == gs_error_Quit))
        code = code1;

    gsapi_delete_instance(minst);

    if ((code == 0) || (code == gs_error_Quit))
        return 0;
    return 1;
}
</pre>

<h3>Example 2</h3>
<pre>
/* Similar to command line gs */

#if defined(_WIN32) &amp;&amp; !defined(_Windows)
# define _Windows
#endif
#ifdef _Windows
/* Compile directly with:
 *   cl -D_Windows -Isrc -Febin\gstest.exe gstest.c bin\gsdll32.lib
 */
# include &lt;windows.h&gt;
# define GSDLLEXPORT __declspec(dllimport)
#endif
#include &lt;stdio.h&gt;
#include "ierrors.h"
#include "iapi.h"

/* stdio functions */
static int GSDLLCALL
gsdll_stdin(void *instance, char *buf, int len)
{
    int ch;
    int count = 0;
    while (count &lt; len) {
        ch = fgetc(stdin);
        if (ch == EOF)
            return 0;
        *buf++ = ch;
        count++;
        if (ch == '\n')
            break;
    }
    return count;
}

static int GSDLLCALL
gsdll_stdout(void *instance, const char *str, int len)
{
    fwrite(str, 1, len, stdout);
    fflush(stdout);
    return len;
}

static int GSDLLCALL
gsdll_stderr(void *instance, const char *str, int len)
{
    fwrite(str, 1, len, stderr);
    fflush(stderr);
    return len;
}

void *minst = NULL;
const char start_string[] = "systemdict /start get exec\n";

int main(int argc, char *argv[])
{
    int code, code1;
    int exit_code;

    code = gsapi_new_instance(&amp;minst, NULL);
    if (code &lt; 0)
        return 1;
    gsapi_set_stdio(minst, gsdll_stdin, gsdll_stdout, gsdll_stderr);
    code = gsapi_set_arg_encoding(minst, GS_ARG_ENCODING_UTF8);
    if (code == 0)
        code = gsapi_init_with_args(minst, argc, argv);
    if (code == 0)
        code = gsapi_run_string(minst, start_string, 0, &amp;exit_code);
    code1 = gsapi_exit(minst);
    if ((code == 0) || (code == gs_error_Quit))
        code = code1;

    gsapi_delete_instance(minst);

    if ((code == 0) || (code == gs_error_Quit))
        return 0;
    return 1;
}
</pre>

<h3>Example 3</h3>

<p>Replace main() in either of the above with the following code,
showing how you can feed Ghostscript piecemeal:</p>
<pre>
const char *command = "1 2 add == flush\n";

int main(int argc, char *argv[])
{
    int code, code1;
    int exit_code;

    code = gsapi_new_instance(&amp;minst, NULL);
    if (code &lt; 0)
        return 1;
    code = gsapi_set_arg_encoding(minst, GS_ARG_ENCODING_UTF8);
    if (code == 0)
        code = gsapi_init_with_args(minst, argc, argv);

    if (code == 0) {
        gsapi_run_string_begin(minst, 0, &amp;exit_code);
        gsapi_run_string_continue(minst, command, strlen(command), 0, &amp;exit_code);
        gsapi_run_string_continue(minst, "qu", 2, 0, &amp;exit_code);
        gsapi_run_string_continue(minst, "it", 2, 0, &amp;exit_code);
        gsapi_run_string_end(minst, 0, &amp;exit_code);
    }

    code1 = gsapi_exit(minst);
    if ((code == 0) || (code == gs_error_Quit))
        code = code1;

    gsapi_delete_instance(minst);

    if ((code == 0) || (code == gs_error_Quit))
        return 0;
    return 1;
}
</pre>

<h3>Example 4</h3>

<p>When feeding Ghostscript piecemeal buffers, one can use the normal
operators to configure things and invoke library routines. For example,
to parse a PDF file one could say:</p>

<pre>
    code = gsapi_run_string(minst, "(example.pdf) .runlibfile", 0, &amp;exit_code);
</pre>

<p>and Ghostscript would open and process the file named "example.pdf" as
if it had been passed as an argument to
<code>gsapi_init_with_args()</code>.</p>
<hr>
<h2><a name="Multiple_threads"></a>Multiple threads</h2>
<p>The Ghostscript library should have been compiled with a
thread safe run time library.
Synchronisation of threads is entirely up to the caller.
The exported <a href="#Exported_functions "><code>gsapi_*()</code></a>
functions must be called from one thread only.</p>
<hr>
<h2><a name="stdio"></a>Standard input and output</h2>
<p>
When using the Ghostscript interpreter library interface, you have a
choice of two standard input/output methods.</p>
<ul>
<li>If you do nothing, the "C" stdio will be used.</li>
<li>If you use <code>gsapi_set_stdio()</code>,  all stdio will
 be redirected to the callback functions you provide.
 This would be used in a graphical user interface environment
 where stdio is not available, or where you wish to process
 Ghostscript input or output.</li>
</ul>
<p>
The callback functions are described in
<a href="../psi/iapi.h"><code>iapi.h</code></a>.</p>

<hr>
<h2><a name="display"></a>Display device</h2>
<p>
The <code>display</code> device is available for use with
the Ghostscript interpreter library. While originally designed
for allowing screen display of rendered output from Ghostscript,
this is now powerful enough to provide a simple mechanism for
getting rendered output suitable for use in all manner of
output scenarios, including printing.</p>
<p>Details of the API and options are given in the file
<code><a href="../devices/gdevdsp.h">gdevdsp.h</a></code>.
This device provides you with access to the raster output of
Ghostscript.  It is the callers responsibility to copy this raster
to a display window or printer.</p>
<p>
In order for this device to operate, it needs access to a structure
containing a set of callback functions, and a callback handle (an
opaque <code>void *</code> that can be used by caller to locate its
own state). There are 2 ways that the device can get this
information, a legacy method, and a modern method.
</p>
<dl>
<dt>Legacy method</dt>
<dd>
<p>The address of the callback structure, is provided
using <code>gsapi_set_display_callback()</code>.
This must be called after
<code>gsapi_new_instance()</code>
and before
<code>gsapi_init_with_args()</code>.</p>
<p>
With this call, the callback handle is passed as NULL by default, but can
be overridden by using a parameter. We actively dislike
this way of working, as we consider passing addresses
via the command line distasteful. The handle can be
set using</p>
<blockquote>
  -sDisplayHandle=1234
</blockquote>
<p>
Where "1234" is a string. The API was changed to use a string
rather than an integer/long value when support for 64 bit systems
arrived. A display "handle" is often a pointer, and since these
command line options have to survive being processed by Postscript
machinery, and Postscript only permits 32 bit number values, a
different representation was required. Hence changing the value
to a string, so that 64 bit values can be supported. The string
formats allowed are:</p>
<blockquote>
<code>1234</code> - implicit base 10
</blockquote>
<blockquote>
<code>10#1234</code> - explicit base 10
</blockquote>
<blockquote>
<code>16#04d2</code> - explicit base 16
</blockquote>
<p>
The "number string" is parsed by the display device to retrieve
the number value, and is then assigned to the void pointer
parameter "pHandle" in the display device structure. Thus, for
a trivial example, passing <code>-sDisplayHandle=0</code> will result
in the first parameter passed to your display device callbacks being:
<code>(void *)0</code>.</p>
<p>
The previous API, using a number value:</p>
<blockquote>
  -dDisplayHandle=1234
</blockquote>
<p>
is still supported on 32 bit systems, but will cause a "typecheck"
error on 64 bit systems, and is considered deprecated. It should
not be used in new code.</p>
</dd>
<dt>Modern method
<dd>
<p>The preferred method is to register a callout handler using
<code><a href="#register_callout">gsapi_register_callout</a></code>.
When this handler is called for the <code>&quot;display&quot;</code>
device, with <code>id = 0</code> (= <code>DISPLAY_CALLOUT_GET_CALLBACK</code>),
then <code>data</code> should point to an empty <code>gs_display_get_callback_t</code>
block, with <code>size = sizeof(gs_display_get_callback_t)</code>.
</p>
<pre>
typedef struct {
    display_callback *callback;
    void *caller_handle;
} gs_display_get_callback_t;
</pre>
<p>The handler should fill in the structure before returning,
with a return code of 0.</p>
</dd>
</dl>
<p>
Note, that the <code>DisplayHandle</code> value is only consulted for
display device callbacks registered using the (legacy, now deprecated)
<code>gsapi_set_display_callback</code> API, not the preferred
<code>gsapi_register_callout</code> based mechanism.

<p>
The device raster format can be configured using</p>
<blockquote>
  -dDisplayFormat=NNNN
</blockquote>
<p>Options include</p>
<ul>
<li> native, gray, RGB, CMYK or separation color spaces.</li>
<li> alpha byte (ignored).</li>
<li> 1 to 16 bits/component.</li>
<li> bigendian (RGB) or littleendian (BGR) order.</li>
<li> top first or bottom first raster.</li>
<li> 16 bits/pixel with 555 or 565 bitfields.</li>
<li> Chunky, Planar and Planar interleaved formats.</li>
<li> "Full screen" or "Rectangle Request" modes of operation.</li>
</ul>
<p>The operation of the device is best described with a walkthrough
of some example code that uses it. For simplicity and clarity, we
have omitted the error handling code in this example; in production
code, every place where we get a <code>code</code> value returned
we should check it for failure (a negative value) and clean up
accordingly.  First, we create an instance of Ghostscript:</p>
<pre>
    void *minst = NULL;
    code = gsapi_new_instance(&amp;minst, NULL);
    code = gsapi_set_stdio(minst, gsdll_stdin, gsdll_stdout, gsdll_stderr);
</pre>
<p>Next, we have to give the display device the address of our
callback structure. In old code, we would do so using something
like this:</p>
<pre>
    code = gsapi_set_display_callback(minst, &amp;display_callback);
</pre>
<p>We strongly recommend that you don't do that, but instead use the
more modern <a href="callout">callout</a> mechanism:</p>
<pre>
    code = gsapi_register_callout(minst, my_callout_handler, state);
</pre>
<p>where <code>state</code> is any <code>void *</code> value you like,
usually a pointer to help you reach any internal state you may need.
Earlier in your code you would have the definition of
<code>my_callout_handler</code> that might look like this:</p>
<pre>
  static int
  my_callout_handler(void *instance,
                     void *callout_handle,
                     const char *device_name,
                     int id,
                     int size,
                     void *data)
{
    /* On entry, callout_handle == the value of state passed in
     * to gsapi_register_callout. */
    /* We are only interested in callouts from the display device. */
    if (device_name == NULL || strcmp(device_name, "display"))
        return -1;

    if (id == DISPLAY_CALLOUT_GET_CALLBACK)
    {
        /* Fill in the supplied block with the details of our callback
         * handler, and the handle to use. In this instance, the handle
         * is the pointer to our test structure. */
        gs_display_get_callback_t *cb = (gs_display_get_callback_t *)data;
        cb->callback = &display_callback;
        cb->caller_handle = callout_handle;
        return 0;
    }
    return -1;
}
</pre>
<p>As you can see, this callout handler only responds to callouts
for the display device, and then only for one particular function
(<code>id</code>). It returns the same <code>display_callback</code>
structure as the deprecated, legacy mechanism passed in using
<code>gsapi_set_display_callback</code>, with the added benefit that
the <code>caller_handle</code> value can be passed in too. In this
example we pass in the same value as was used for <code>callout_handle</code>,
but implementations are free to use any value they want.</p>
<p>Returning to our example, we now set up a set of arguments to
setup Ghostscript:</p>
<pre>
    int argc = 0;
    /* Allow for up to 32 args of up to 64 chars each. */
    char argv[32][64];
    sprintf(argc[argc++], "gs");
    sprintf(argv[argc++], "-sDEVICE=display");
</pre>
<p>The zeroth arg is a dummy argument to match the standard C mechanism
for passing arguments to a program. Traditionally this is the name of
the program being invoked. Next, we tell Ghostscript to use the display
device.</p>
<pre>
    sprintf(argv[argc++], "-sDEVICE=display");
</pre>
Next we tell the display device what output format to use. The
format is flexible enough to support common Windows, OS/2, Linux
and Mac raster formats.  <p>The format values are described in
<code><a href="../devices/gdevdsp.h">gdevdsp.h</a></code>.
To select the display device with a Windows 24-bit RGB raster:</p>
<pre>
    sprintf(argv[argc++], "-dDisplayFormat=%d",
        DISPLAY_COLORS_RGB | DISPLAY_ALPHA_NONE | DISPLAY_DEPTH_8 |
        DISPLAY_LITTLEENDIAN | DISPLAY_BOTTOMFIRST);
</pre>
<p>If (and only if) you used the legacy mechanism described above, you
will need another argument to pass in the <code>caller_handle</code>
value to be parroted back to the functions listed within
<code>display_callback</code>:</p>
<pre>
    sprintf(arg2, "-dDisplayHandle=%d", callout_handle);
</pre>
<p>Any other arguments that you want can be added to the end of
the command line, typically including a file to run. Then we pass
that all to Ghostscript:
<pre>
    code = gsapi_init_with_args(minst, argc, argv);
</pre>

<p><a name="display_callback"></a>At this point you should start to
see your display callback functions being called. Exactly which callback
functions are provided, and how they respond will determine exactly
how the display device operates. The primary choice will be whether the
device runs in &quot;full page&quot; or &quot;rectangle request&quot;
  mode. Details of these are given below.</p>

<p>Once we have finished processing the file, we can process
other files using <code>gsapi_run_file</code>, or feed in data
using <code>gsapi_run_string</code>. Once you have finished, you
can shut the interpreter down and exit, using:</p>

<pre>
  code = gsapi_exit(minst);
  gsapi_delete_instance(minst);
</pre>

<p>A full list of the display callback functions can be found in
<code><a href="../devices/gdevdsp.h">gdevdsp.h</a></code>. There
are several different versions of the callback, corresponding to
different &quot;generations&quot; of the device. In general
you should use the latest one. The <code>size</code> field of
the structure should be initialised to the size of the structure
in bytes.</p>

<h3><a name="display_open"></a>display_open</h3>

<pre>int (*display_open)(void *handle, void *device);</pre>

<p>This function will be called when the display device is
opened. The device may be opened and closed many times,
sometimes without any output being produced.</p>

<h3><a name="display_preclose"></a>display_preclose</h3>

<pre>int (*display_preclose)(void *handle, void *device);</pre>

<p>This function will be called when the display device is
about to be closed. The device will not actually be closed
until this function returns.</p>

<h3><a name="display_close"></a>display_close</h3>

<pre>int (*display_close)(void *handle, void *device);</pre>

<p>This function will be called once the display device has
been closed. There will be no more events from the device
unless/until it is reopened.</p>

<h3><a name="display_presize"></a>display_presize</h3>

<pre>int (*display_presize)(void *handle, void *device,
        int width, int height, int raster, unsigned int format);</pre>

<p>This function will be called when the display device is
about to be resized. The device will only be resized if this
function returns 0.</p>

<h3><a name="display_size"></a>display_size</h3>

<pre>int (*display_size)(void *handle, void *device, int width, int height,
  int raster, unsigned int format, unsigned char *pimage);</pre>

<p>This function will be called when the display device is
has been resized. The pointer to the raster image is pimage.</p>

<h3><a name="display_sync"></a>display_sync</h3>

<pre>int (*display_sync)(void *handle, void *device);</pre>

<p>This function may be called periodically during display
to flush the page to the display.</p>

<h3><a name="display_page"></a>display_page</h3>

<pre>int (*display_page)(void *handle, void *device, int copies, int flush);</pre>

<p>This function is called on a &quot;showpage&quot; operation
(i.e. at the end of every page). Operation will continue as soon as
this function returns.</p>

<h3><a name="display_update"></a>display_update</h3>

<pre>int (*display_update)(void *handle, void *device,
        int x, int y, int w, int h);</pre>

<p>This function <strong>may</strong> get called repeatedly
during rendering to indicate that an area of the output has
been updated. Certain types of rendering will not see this
function called back at all (in particular files using
transparency).</p>

<h3><a name="display_memalloc"></a>display_memalloc</h3>

<pre>int (*display_memalloc)(void *handle, void *device,
        size_t long size);</pre>

<p><strong>Note:</strong> In older versions of this API,
size is an <code>unsigned long</code> rather than a
<code>size_t</code>.</p>
<p>If this function pointer is sent as NULL, then the
display device will handle all the memory allocations
internally, and will always work in full page rendering
mode.</p>
<p>Otherwise, this function will be called to allocate
the storage for the page to be rendered into. If a non-NULL
value is returned, then the device will proceed to render
the full page into it. If NULL is returned, then the device
will check a) whether we are using a V2 or greater display
callback structure and b) whether that structure specifies
a <code>rectangle_request</code> function pointer.</p>
<p>If both of those conditions are true, then the device
will continue in rectangle request mode. Otherwise it will
fail with an out of memory error.</p>


<h3><a name="display_memfree"></a>display_memfree</h3>

<pre>int (*display_memfree)(void *handle, void *device, void *ptr);</pre>

<p>This function should be NULL if and only if
<code><a href="#display_memalloc">display_memalloc</a></code> is
NULL. Any memory allocated using <code>display_memalloc</code> will be
freed via this function.</p>

<h3><a name="display_separation"></a>display_separation</h3>
<pre>int (*display_separation)(void *handle, void *device,
        int component, const char *component_name,
        unsigned short c, unsigned short m,
        unsigned short y, unsigned short k);</pre>

<p>When using <code>DISPLAY_COLORS_SEPARATION</code>, this function
  will be called once for every separation component - first
  &quot;Cyan&quot;, &quot;Magenta&quot;, &quot;Yellow&quot; and
  &quot;Black&quot;, then any spot colors used. The supplied
  <code>c</code>, <code>m</code>, <code>y</code> and <code>k</code>
  values give the equivalent color for each spot. Each colorant
  value ranges from 0 (for none) to 65535 (full).</p>
<p>In separation color mode you are expected to count the number
of calls you get to this function after each
<code><a href="#display_size">display_size</a></code> to know how many
colors you are dealing with.</p>

<h3><a name="display_adjust_band_height"></a>display_adjust_band_height</h3>
<pre>int (*display_adjust_band_height)(void *handle, void *device,
        int bandheight);</pre>

<p>When running in &quot;rectangle request mode&quot; the device
first renders the page to a display list internally. It can then
be played back repeatedly so that different regions (rectangles)
of the page can be extracted in sequence. A common use of this is
to support &quot;banded&quot; operation, where the page is divided
into multiple non-overlapping bands of a fixed height.</p>
<p>The display device itself will pick an appropriate band height
for it to use. If this function pointer is left as NULL then this
value will be used unchanged. Otherwise, the proposed value will
be offered to this function. This function can override the choice
of bandheight, by returning the value that it would like to be
used in preference.</p>
<p>In general, this figure should (as much as possible) only be
adjusted downwards. For example, a device targeting an inkjet printer
with 200 nozzles in the print head might like to extract bands
that are a multiple of 200 lines high. So the function might
return <code>max(200, 200*(bandheight/200))</code>. If the function
returns 0, then the existing value will be used unchanged.</p>
<p>Any size rectangle can be chosen with any size bandheight,
so ultimately the value chosen here will not matter much. It
may make some small difference in speed in some cases.</p>

<h3><a name="display_rectangle_request"></a>display_rectangle_request</h3>
<pre>int (*display_rectangle_request)(void *handle, void *device,
        void **memory, int *ox, int *oy,
        int *raster, int *plane_raster,
        int *x, int *y, int *w, int *h);</pre>

<p>If the display device chooses to use rectangle request mode,
this function will be called repeatedly to request a rectangle
to render. Ghostscript will render the rectangle, and call this
function again. The implementer is expected to handle the rectangle
that has just been rendered, and to return the details of another
rectangle to render. This will continue until a rectangle with
zero height or width is returned, whereupon Ghostscript will
continue operation.</p>
<p>On entry, <code>*raster</code> and <code>*plane_raster</code>
are set to the values expected by the format in use. All the
other pointers point to uninitialised values.</p>
<p>On exit, the values should be updated appropriately. The
implementor is expected to store the values returned so that
the rendered output given can be correctly interpreted when
  control returns to this function.</p>
<p><code>memory</code> should be updated to point to a block of
memory to use for the rendered output. Pixel (<code>*ox</code>,
<code>*oy</code>) is the first pixel represented in that block.
<code>*raster</code> is the number of bytes difference between
the address of component 0 of Pixel(<code>*ox</code>, <code>*oy</code>)
and the address of component 0 of Pixel(<code>*ox</code>,
<code>1+*oy</code>). <code>*plane_raster</code> is the number of
bytes difference between the address of component 0 of
Pixel(<code>*ox</code>, <code>*oy</code>) and the address of
component 1 of Pixel(<code>*ox</code>, <code>*oy</code>), if in
planar mode, 0 otherwise. <code>*x</code>, <code>*y</code>,
<code>*w</code> and <code>*h</code> give the rectangle requested
within that memory block.</p>
<p>Any set of rectangles can be rendered with this method, so this
can be used to drive Ghostscript in various ways. Firstly, it is
simple to request a set of non-overlapping &quot;bands&quot; that
cover the page, to drive a printer. Alternatively, rectangles can
be chosen to fill a given block of memory to implement a window
panning around a larger page. Either the whole image could be
redrawn each time, or smaller rectangles around the edge of the
panned area could be requested. The choice is down to the caller.</p>

<p>
Some examples of driving this code in full page mode are in
<code><a href="../psi/dwmain.c">dwmain.c</a></code> (Windows),
<code><a href="../psi/dpmain.c">dpmain.c</a></code> (OS/2) and
<code><a href="../psi/dxmain.c">dxmain.c</a></code> (X11/Linux), and
<code><a href="../psi/dmmain.c">dmmain.c</a></code> (MacOS Classic or Carbon).</p>
<p>Alternatively an example that drives this code in both full page
and rectangle request mode can be found in
<code><a href="../demos/c/api_test.c">api_test.c</a></code>.</p>

<p>
On some platforms, the calling convention for the display device callbacks in
<code><a href="../devices/gdevdsp.h">gdevdsp.h</a></code>
is not the same as the exported
<a href="#Exported_functions "><code>gsapi_*()</code></a>
functions in <a href="../psi/iapi.h"><code>iapi.h</code></a>.</p></p>

<!-- [2.0 end contents] ==================================================== -->
<!-- [3.0 begin visible trailer] =========================================== -->
<hr>
<p>
<small>Copyright &copy; 2000-2021 Artifex Software, Inc. All rights reserved.</small></p>

<p>
This software is provided AS-IS with no warranty, either express or
implied.</p>

This software is distributed under license and may not be copied, modified
or distributed except as expressly authorized under the terms of that
license.  Refer to licensing information at <a href="https://www.artifex.com">https://www.artifex.com</a>
or contact Artifex Software, Inc.,  1305 Grant Avenue - Suite 200,
Novato, CA 94945, U.S.A., +1(415)492-9861, for further information.</p>

<p>
<small>Ghostscript version 9.55.0, 27 September 2021

<!-- [3.0 end visible trailer] ============================================= -->

<!--FINISH EDITING HERE-->

    </div>
    </div>
    </div>

    <div class="footer">
    <div class="row">
        <div class="col-7 footleft">
        <ul>
            <li><a href="https://artifex.com/contact-us/" target="blank">CONTACT US</a></li>
            <li><a href="https://artifex.com/about-us/" target="blank">ABOUT</a></li>
            <li><a href="https://ghostscript.com/security.html">SECURITY</a></li>
        </ul>
        </div>
        <div class="col-1 footcenter">
         <ul>
           <li><a href="https://artifex.com/support/" target="blank">SUPPORT</a></li>
           <li><a href="https://artifex.com/blog/artifex/" target="blank">BLOG</a></li>
           <li><a href="https://artifex.com/privacy-policy/" target="blank">PRIVACY</a></li>
           </ul>
        </div>
        <div class="col-ft-3 footright"><img src="images/Artifex_logo.png" width="194" height="40" alt=""/> <br>
               Copyright 2019-2021 Artifex Software, Inc. <br>
            All rights reserved.
        </div>
          </div>
    </div>

    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="index.js"></script>
</body>
</html>
